<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shift Goals: NICU Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vt323&display=swap');

        :root {
            --crt-bg: #111827;
            --monitor-border: #374151;
            --monitor-bg: #000000;
            --text-primary: #e2e8f0;
            --accent-green: #4ade80;
            --accent-blue: #60a5fa;
            --accent-red: #f87171;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'Vt323', monospace;
            touch-action: none;
            user-select: none;
            color: var(--text-primary);
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }

        canvas {
            background-color: #1e293b;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
        }

        /* --- CRT EFFECT LAYERS --- */
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            box-shadow: inset 0 0 80px rgba(0, 0, 0, 0.7);
        }

        .crt-flicker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            background: rgba(255, 255, 255, 0.02);
            opacity: 0;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% {
                opacity: 0.01;
            }

            50% {
                opacity: 0.03;
            }

            100% {
                opacity: 0.01;
            }
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 16px;
            box-sizing: border-box;
            z-index: 20;
        }

        .hud-panel {
            background: rgba(17, 24, 39, 0.9);
            color: #fff;
            padding: 8px 16px;
            border-radius: 2px;
            pointer-events: auto;
            font-size: 1.8rem;
            border: 2px solid #475569;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.5);
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
            white-space: nowrap;
            position: relative;
        }

        .hud-panel::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        .pause-btn {
            background: #991b1b;
            border-color: #ef4444;
            color: #fecaca;
            cursor: pointer;
            transition: all 0.1s;
        }

        .pause-btn:hover {
            background: #b91c1c;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
        }

        .pause-btn:active {
            transform: translateY(2px);
        }

        .mug-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: #1e40af;
            color: #bfdbfe;
            border: 2px solid #60a5fa;
            padding: 10px 20px;
            font-size: 1.5rem;
            font-family: 'Vt323', monospace;
            cursor: pointer;
            box-shadow: 0 4px 0 #1e3a8a, 0 0 10px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            display: none;
            z-index: 50;
            transition: transform 0.1s;
        }

        .mug-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1e3a8a, 0 0 15px rgba(96, 165, 250, 0.4);
        }

        .mug-btn:active {
            transform: translateY(2px);
            box-shadow: 0 0 0 #1e3a8a;
        }

        #sanity-container-ui {
            min-width: 220px;
        }

        #sanity-bar-container {
            width: 100%;
            height: 24px;
            background: #1f2937;
            border: 2px solid #4b5563;
            margin-top: 5px;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }

        /* Scanline for the bar */
        #sanity-bar-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 100% 4px;
            pointer-events: none;
        }

        #sanity-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            box-shadow: 0 0 10px #22c55e;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s;
        }

        #log-panel {
            position: absolute;
            right: 16px;
            top: 100px;
            bottom: 16px;
            width: 400px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #334155;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            padding: 12px;
            overflow-y: hidden;
            pointer-events: none;
            font-family: 'Vt323', monospace;
            display: flex;
            flex-direction: column-reverse;
        }

        /* Terminal styling for log */
        #log-panel::before {
            content: 'SYSTEM LOG //';
            display: block;
            color: #475569;
            font-size: 1rem;
            border-bottom: 1px dashed #334155;
            margin-bottom: 8px;
            padding-bottom: 4px;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            line-height: 1.2;
            background: rgba(255, 255, 255, 0.03);
            border-left: 2px solid transparent;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(10px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .log-time {
            color: #64748b;
            font-size: 0.9rem;
            margin-right: 6px;
            font-family: monospace;
        }

        .log-speaker {
            font-weight: bold;
            margin-right: 6px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-msg {
            font-size: 1.1rem;
            color: #cbd5e1;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.2);
        }

        /* Log Colors - Pop more against dark bg */
        .sp-resident {
            color: #60a5fa;
        }

        .sp-mom {
            color: #f472b6;
        }

        .sp-dad {
            color: #38bdf8;
        }

        .sp-surgeon {
            color: #ef4444;
        }

        .sp-nurse {
            color: #4ade80;
            border-left-color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .sp-admin {
            color: #c084fc;
        }

        #modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: #0f172a;
            color: white;
            padding: 2.5rem;
            border: 2px solid #3b82f6;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.8);
            text-align: center;
            max-width: 650px;
            position: relative;
        }

        .modal-content::after {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            pointer-events: none;
        }

        .btn {
            background: #1e3a8a;
            color: #bfdbfe;
            border: 2px solid #60a5fa;
            padding: 12px 24px;
            font-size: 1.6rem;
            font-family: 'Vt323', monospace;
            cursor: pointer;
            margin-top: 1rem;
            box-shadow: 0 4px 0 #172554, 0 10px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: #1e40af;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #172554, 0 15px 15px rgba(59, 130, 246, 0.2);
            text-shadow: 0 0 8px rgba(191, 219, 254, 0.8);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 0 0 #172554;
        }

        #settings-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 150;
            pointer-events: auto;
        }

        #settings-overlay input[type="range"] {
            cursor: pointer;
            accent-color: #3b82f6;
        }

        input[type="checkbox"] {
            accent-color: #3b82f6;
            transform: scale(1.5);
        }

        #auto-nurse-toggle {
            position: static;
            /* top: 10px; */
            /* left: 50%; */
            /* transform: translateX(-50%); */
            background: #0f172a;
            border: 2px solid #475569;
            color: #94a3b8;
            padding: 6px 14px;
            font-family: 'Vt323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        #auto-nurse-toggle.active {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #34d399;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.2);
        }

        #character-roster-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }

        #character-roster-overlay .roster-content {
            background: #0f172a;
            padding: 40px;
            border: 2px solid #6366f1;
            box-shadow: 0 0 40px rgba(99, 102, 241, 0.2);
            max-width: 600px;
            width: 90%;
            text-align: center;
            position: relative;
        }

        /* Grid Lines overlay for Roster */
        #character-roster-overlay .roster-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#1e293b 1px, transparent 1px), linear-gradient(90deg, #1e293b 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }

        .roster-inner {
            position: relative;
            z-index: 1;
        }

        #character-sprite-display {
            margin: 20px auto;
            width: 200px;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            border: 2px solid #333;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }

        /* Utility classes for text shadows */
        .neon-text-blue {
            text-shadow: 0 0 10px rgba(59, 130, 246, 0.8);
        }

        .neon-text-green {
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.8);
        }

        .neon-text-red {
            text-shadow: 0 0 10px rgba(248, 113, 113, 0.8);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <!-- Visual Effect Layers -->
        <div class="crt-overlay"></div>
        <div class="crt-flicker"></div>

        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div class="flex justify-between w-full items-start" id="game-ui-top">
                <div class="flex gap-4 items-start">
                    <div class="hud-panel">
                        <div class="text-gray-400 text-sm mb-1 tracking-widest">SYSTEM TIME</div>
                        <div class="text-3xl neon-text-blue" id="timer">07:00</div>
                        <div class="border-t border-gray-600 mt-2 pt-1 flex justify-between gap-4">
                            <span class="text-gray-400 text-base">SCORE</span>
                            <span id="score" class="text-yellow-400">0</span>
                        </div>
                    </div>

                    <div class="flex flex-col gap-2">
                        <button id="auto-nurse-toggle" onclick="toggleAutoNurse()">AUTO NURSE</button>
                        <button id="pause-btn" class="hud-panel pause-btn" onclick="togglePause()">
                            ‚è∏ PAUSE
                        </button>
                        <button id="hud-settings-btn" class="hud-panel" onclick="openSettings()"
                            style="font-size: 2.5rem; padding: 0; width: 50px; background: transparent; border: none; box-shadow: none; display: flex; justify-content: center; align-items: center; color: #475569; cursor: pointer;">
                            ‚öô
                        </button>
                    </div>
                </div>

                <div class="hud-panel" id="sanity-container-ui">
                    <div class="flex justify-between items-end mb-1">
                        <span class="text-gray-400 text-sm tracking-widest">SANITY LEVELS</span>
                        <span id="sanity-percent" class="text-sm text-green-400">100%</span>
                    </div>
                    <div id="sanity-bar-container">
                        <div id="sanity-bar"></div>
                    </div>
                </div>
            </div>

            <div id="log-panel">
                <div class="log-entry"><span class="log-time">07:00</span> <span class="log-msg text-gray-500">System
                        Initialized. Good luck.</span></div>
            </div>

            <div class="hud-panel self-center" id="message-box"
                style="opacity: 0; transition: opacity 0.5s; background: rgba(0,0,0,0.9); border: 2px solid #fff; box-shadow: 0 0 30px white;">
                <span id="message-text" class="text-4xl text-white neon-text-blue">Shift Started!</span>
            </div>
            <!-- restart-btn removed -->
        </div>

        <div id="modal-overlay">
            <div class="modal-content" style="max-width: 800px;">
                <h1 class="text-5xl mb-2 text-blue-400 neon-text-blue" style="font-family: 'Vt323';">SHIFT GOALS</h1>
                <p class="text-xl mb-6 text-blue-200 tracking-widest border-b border-blue-900 pb-2">NICU SIMULATION
                    MODULE v2.0</p>

                <div class="grid grid-cols-2 gap-8 text-left text-lg mb-8">
                    <div class="bg-slate-900/50 p-4 border border-slate-700">
                        <h3 class="text-green-400 font-bold mb-2 neon-text-green">>> POSITIVES</h3>
                        <ul class="space-y-2 text-slate-300">
                            <li>‚òï <strong>Coffee:</strong> Speed +50%</li>
                            <li>üçï <strong>Pizza:</strong> Sanity +20</li>
                            <li>üßª <strong>Break:</strong> Sanity MAX</li>
                            <li>ü™ë <strong>Chair:</strong> Regen Sanity</li>
                        </ul>
                    </div>
                    <div class="bg-slate-900/50 p-4 border border-slate-700">
                        <h3 class="text-red-400 font-bold mb-2 neon-text-red">>> HAZARDS</h3>
                        <ul class="space-y-2 text-slate-300">
                            <li>üò∑ <strong>Surgeon:</strong> High Drain</li>
                            <li>üë®‚Äç‚öïÔ∏è <strong>Resident:</strong> Confused</li>
                            <li>üéÅ <strong>Admin:</strong> "Wellness" Trap</li>
                        </ul>
                    </div>
                </div>
                <p class="text-md italic mb-6 text-gray-500 blink">"Earn digital stickers for your mug!"</p>
                <div class="flex gap-4 justify-center">
                    <button class="btn w-40" onclick="startGame()">START</button>
                    <button class="btn w-16" onclick="openSettings()"
                        style="background: transparent; border: none; box-shadow: none; color: #475569; padding: 0; display: flex; justify-content: center; align-items: center; font-size: 4rem;">
                        ‚öô
                    </button>
                </div>
            </div>
        </div>

        <div id="settings-overlay" style="display: none;">
            <div class="modal-content" style="max-width: 450px;">
                <h2 class="text-4xl mb-6 text-blue-400 neon-text-blue">SETTINGS</h2>

                <div class="text-left space-y-6 bg-slate-900/50 p-6 border border-slate-700">
                    <div class="flex justify-between items-center">
                        <label class="text-xl text-blue-200">Volume</label>
                        <input type="range" id="volume-slider" min="0" max="100" value="50" class="w-32"
                            onchange="updateVolume(this.value)">
                    </div>

                    <div class="flex justify-between items-center">
                        <label for="setting-night-shift" class="text-xl text-blue-200">Night Shift Mode</label>
                        <input type="checkbox" id="setting-night-shift" onchange="toggleNightShift()">
                    </div>

                    <div class="flex justify-between items-center">
                        <label for="setting-short-staffed" class="text-xl text-blue-200">Short Staffed</label>
                        <input type="checkbox" id="setting-short-staffed" onchange="toggleShortStaffed()">
                    </div>

                    <div class="flex justify-between items-center">
                        <label for="setting-auto-nurse" class="text-xl text-blue-200">Auto Pilot</label>
                        <input type="checkbox" id="setting-auto-nurse" onchange="toggleAutoNurse()">
                    </div>

                    <div class="flex justify-between items-center">
                        <label for="setting-alt-sprites" class="text-xl text-blue-200">Hi-Res Sprites</label>
                        <input type="checkbox" id="setting-alt-sprites" onchange="toggleAltSprites()">
                    </div>
                </div>

                <div class="flex gap-2 mt-4">
                    <button class="btn flex-1 py-2 text-xl" onclick="openCharacterRoster('standard')">
                        ROSTER
                    </button>
                    <button class="btn flex-1 py-2 text-xl" onclick="resetTutorial()"
                        style="background: #334155; border-color: #64748b;">
                        RESET TUTORIAL
                    </button>
                </div>

                <div class="flex gap-2 mt-2">
                    <button class="btn w-full py-2 text-xl" onclick="openCharacterRoster('alt')"
                        style="background-color: #6b46c1;">
                        ALT DESIGNS ROSTER
                    </button>
                </div>

                <button class="btn mt-6 w-full" onclick="closeSettings()">SAVE & EXIT</button>
            </div>
        </div>

        <div id="character-roster-overlay">
            <div class="roster-content">
                <div class="roster-inner">
                    <h2 class="text-4xl mb-4 text-indigo-400 neon-text-blue" style="font-family: 'Vt323', monospace;">
                        DATABASE</h2>

                    <div id="character-sprite-display"></div>

                    <h3 class="text-3xl text-white mb-1 mt-4" id="character-name"
                        style="font-family: 'Vt323', monospace;"></h3>
                    <p class="text-xl text-indigo-300 mb-4" id="character-role"
                        style="font-family: 'Vt323', monospace;"></p>
                    <div class="bg-slate-900/80 p-3 border border-slate-700 mb-4">
                        <p class="text-xl text-pink-300 italic" id="character-quote"
                            style="font-family: 'Vt323', monospace;"></p>
                    </div>

                    <div class="text-left text-slate-300 mb-6 bg-slate-900/50 p-4 border border-slate-800"
                        id="character-stats" style="font-family: 'Vt323', monospace; font-size: 20px;"></div>

                    <div class="flex justify-between mb-4 gap-4">
                        <button class="btn flex-1" onclick="prevCharacter()">PREV</button>
                        <span class="text-white" id="character-counter"
                            style="font-family: 'Vt323', monospace; font-size: 24px; align-self: center;">1 / 9</span>
                        <button class="btn flex-1" onclick="nextCharacter()">NEXT</button>
                    </div>

                    <button class="btn w-full" onclick="closeCharacterRoster()"
                        style="background: #334155; border-color: #64748b;">CLOSE DB</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const sanityBar = document.getElementById('sanity-bar');
        const sanityPercent = document.getElementById('sanity-percent');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.querySelector('.modal-content');
        const logPanel = document.getElementById('log-panel');
        const pauseBtn = document.getElementById('pause-btn');
        // const restartBtn = document.getElementById('restart-btn'); // Removed
        const gameUiTop = document.getElementById('game-ui-top');

        const SHIFT_START = 7 * 60;
        const SHIFT_END = 19 * 60;
        const GAME_DURATION_SECONDS = 300; // 5 Minutes
        const MS_PER_GAME_MINUTE = (GAME_DURATION_SECONDS * 1000) / (12 * 60);

        // Audio context for sound effects
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Polyfill for roundRect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        function playBeep(frequency = 440, duration = 100) {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.frequency.value = frequency;
                gainNode.gain.setValueAtTime(0.3 * settings.volume, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration / 1000);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + duration / 1000);
            } catch (e) {
                // Audio failed, no big deal
            }
        }




        let settings = {
            volume: 0.5,
            nightShift: false,
            shortStaffed: false,
            tutorialSeen: false,
            autoNurse: false,
            altSprites: false
        };

        // Load from localStorage on page load
        function loadSettings() {
            const saved = localStorage.getItem('nicuSettings');
            if (saved) {
                Object.assign(settings, JSON.parse(saved));
                gameState.nightShift = settings.nightShift;
                gameState.shortStaffed = settings.shortStaffed;
                gameState.altSprites = settings.altSprites;
            }
            // Update UI elements based on loaded settings
            const volSlider = document.getElementById('volume-slider');
            if (volSlider) volSlider.value = settings.volume * 100;

            const nightCheckbox = document.getElementById('setting-night-shift');
            if (nightCheckbox) nightCheckbox.checked = settings.nightShift;

            const staffCheckbox = document.getElementById('setting-short-staffed');
            if (staffCheckbox) staffCheckbox.checked = settings.shortStaffed;

            const autoNurseCheckbox = document.getElementById('setting-auto-nurse');
            if (autoNurseCheckbox) autoNurseCheckbox.checked = settings.autoNurse;

            updateAutoToggleButton();
            updateSettingsUI(); // Call this to ensure other UI elements are updated
        }

        function saveSettings() {
            localStorage.setItem('nicuSettings', JSON.stringify(settings));
            updateAutoToggleButton();
        }

        function openSettings() {
            document.getElementById('settings-overlay').style.display = 'flex';
            updateSettingsUI();
        }

        function closeSettings() {
            document.getElementById('settings-overlay').style.display = 'none';
            saveSettings();
        }

        function updateSettingsUI() {
            const volSlider = document.getElementById('volume-slider');
            if (volSlider) volSlider.value = settings.volume * 100;

            const nightCheckbox = document.getElementById('setting-night-shift');
            if (nightCheckbox) nightCheckbox.checked = settings.nightShift;

            const staffCheckbox = document.getElementById('setting-short-staffed');
            if (staffCheckbox) staffCheckbox.checked = settings.shortStaffed;

            const autoNurseCheckbox = document.getElementById('setting-auto-nurse');
            if (autoNurseCheckbox) autoNurseCheckbox.checked = settings.autoNurse;

            const altSpritesCheckbox = document.getElementById('setting-alt-sprites');
            if (altSpritesCheckbox) altSpritesCheckbox.checked = settings.altSprites;
        }

        function updateVolume(val) {
            settings.volume = val / 100;
        }

        function toggleNightShift() {
            settings.nightShift = !settings.nightShift;
            gameState.nightShift = settings.nightShift;
            updateSettingsUI();
            saveSettings();
        }

        function toggleShortStaffed() {
            settings.shortStaffed = !settings.shortStaffed;
            gameState.shortStaffed = settings.shortStaffed;
            updateSettingsUI();
            saveSettings();
        }

        function resetTutorial() {
            settings.tutorialSeen = false;
            saveSettings();
            alert('Tutorial will show on next shift!');
        }

        function toggleAutoNurse() {
            settings.autoNurse = !settings.autoNurse;
            saveSettings();
            // Update HUD button if visible
            const hudBtn = document.getElementById('hud-auto-nurse');
            if (hudBtn) {
                hudBtn.classList.toggle('bg-green-600', settings.autoNurse);
                hudBtn.classList.toggle('bg-gray-600', !settings.autoNurse);
                // hudBtn.innerText = settings.autoNurse ? "AUTO: ON" : "AUTO: OFF";
            }
            updateAutoToggleButton();
        }

        function toggleAltSprites() {
            settings.altSprites = !settings.altSprites;
            gameState.altSprites = settings.altSprites;
            saveSettings();
        }

        function updateAutoToggleButton() {
            const btn = document.getElementById('auto-nurse-toggle');
            if (btn) {
                if (settings.autoNurse) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }

        // Character Roster Data
        const characters = [
            { name: "NICU Nurse", role: "The Hero", sprite: "nurse", quote: "I need a break.", stats: ["Coffee Dependency: CRITICAL", "Sanity Management: Expert", "Multi-tasking: God Tier", "Patience Level: Variable"] },
            { name: "Surgeon", role: "The Specialist", sprite: "surgeon", quote: "I don't know why they don't listen to ME.", stats: ["Ego Size: Massive", "Bedside Manner: Non-existent", "Orders: Contradictory", "Availability: Sporadic"] },
            { name: "Resident", role: "The Clueless", sprite: "resident", quote: "Uh... where are you going?", stats: ["Knowledge: Theoretical Only", "Sleep Deprivation: 100%", "Questions Asked: Too Many", "Help Provided: Minimal"] },
            { name: "Mom", role: "The Worried Parent", sprite: "mom", quote: "Is that machine beeping normal?!", stats: ["Anxiety Level: High", "Questions: Endless", "Google MD: Certified", "Love: Infinite"] },
            { name: "Dad", role: "The Partner", sprite: "dad_bottle", quote: "My wife has a question...", stats: ["Support Role: Active", "Medical Knowledge: Learning", "Snack Runs: Frequent", "Stress Level: Rising"] },
            { name: "Coffee", role: "The Lifesaver", sprite: "coffee", quote: "[Steam noises]", stats: ["Speed Boost: +80%", "Sanity Restored: +5", "Temperature: Lava", "Required: Always"] },
            { name: "Pizza", role: "The Cold Comfort", sprite: "pizza", quote: "Still edible!", stats: ["Temperature: Room", "Quality: Questionable", "Sanity Boost: +20", "Source: Break Room"] },
            { name: "Bathroom Break", role: "The Necessity", sprite: null, quote: "Finally!", stats: ["Relief: Maximum", "Sanity Boost: Full", "Duration: Too Short", "Frequency: Never Enough"] },
            { name: "Hand Sanitizer", role: "The Essential", sprite: null, quote: "*squirt*", stats: ["Alcohol Content: 70%", "Skin Dryness: +50", "Germ Kill: 99.9%", "Use Rate: Constant"] },
            { name: "Floor Cleaner", role: "The Hazard", sprite: "floorcleaner", quote: "Wet Floor!", stats: ["Slip Risk: HIGH", "Timing: Always Terrible", "Coverage: Entire Hallway", "Warning Signs: Ignored"] },
            { name: "Admin Gift", role: "The Wellness Trap", sprite: "admingift", quote: "Heroes Work Here!", stats: ["Actual Value: $0.02", "Sanity Cost: -10", "Message: We 'Appreciate' You", "Usefulness: Zero"] },
            { name: "Baby", role: "The Patient", sprite: null, quote: "*cries in NICU*", stats: ["Size: Tiny", "Needs: Constant", "Cuteness: Maximum", "Worth It: 100%"] }
        ];

        let currentCharacterIndex = 0;
        let currentRosterMode = 'standard';

        function openCharacterRoster(mode = 'standard') {
            currentRosterMode = mode;
            document.getElementById('settings-overlay').style.display = 'none';
            document.getElementById('character-roster-overlay').style.display = 'flex';
            currentCharacterIndex = 0;
            displayCharacter(currentCharacterIndex);
        }

        function closeCharacterRoster() {
            document.getElementById('character-roster-overlay').style.display = 'none';
            document.getElementById('settings-overlay').style.display = 'flex';
        }

        function nextCharacter() {
            currentCharacterIndex = (currentCharacterIndex + 1) % characters.length;
            displayCharacter(currentCharacterIndex);
        }

        function prevCharacter() {
            currentCharacterIndex = (currentCharacterIndex - 1 + characters.length) % characters.length;
            displayCharacter(currentCharacterIndex);
        }

        function displayCharacter(index) {
            const char = characters[index];
            document.getElementById('character-name').textContent = char.name;
            document.getElementById('character-role').textContent = char.role;
            document.getElementById('character-quote').textContent = `"${char.quote}"`;
            document.getElementById('character-counter').textContent = `${index + 1} / ${characters.length}`;
            const statsDiv = document.getElementById('character-stats');
            statsDiv.innerHTML = char.stats.map(stat => `<div>‚Ä¢ ${stat}</div>`).join('');
            const spriteDiv = document.getElementById('character-sprite-display');
            spriteDiv.innerHTML = '';
            if (char.sprite) {
                const spriteCanvas = document.createElement('canvas');
                spriteCanvas.width = 200;
                spriteCanvas.height = 200;
                const spriteCtx = spriteCanvas.getContext('2d');
                // Fill with dark background
                spriteCtx.fillStyle = '#2d3748';
                spriteCtx.fillRect(0, 0, 200, 200);
                drawSprite(spriteCtx, char.sprite, 100, 100, 20, currentRosterMode === 'alt');
                spriteDiv.appendChild(spriteCanvas);
            } else {
                const emoji = document.createElement('div');
                emoji.style.fontSize = '80px';
                if (char.name === 'Pizza') emoji.textContent = 'üçï';
                else if (char.name === 'Bathroom Break') emoji.textContent = 'üßª';
                else if (char.name === 'Hand Sanitizer') emoji.textContent = 'üß¥';
                else if (char.name === 'Floor Cleaner') emoji.textContent = 'üßπ';
                else if (char.name === 'Admin Gift') emoji.textContent = 'üéÅ';
                else if (char.name === 'Baby') emoji.textContent = 'üë∂';
                spriteDiv.appendChild(emoji);
            }
        }
        let gameState = {
            mode: 'MENU',
            running: false,
            paused: false,
            pausePhrase: "PAUSED",
            time: SHIFT_START,
            sanity: 100,
            score: 0,
            lastTime: 0,
            coffeeBoost: 0,
            mugStickers: [],
            inventoryStickers: [],
            stickerDelay: 0,
            displayedScore: 0,
            mugFillHeight: 0,
            // Sprint 5: Difficulty modifiers
            shortStaffed: false,
            nightShift: false,
            eventTimer: 0,
            // Sprint 5: Stats
            stats: {
                babiesFed: 0,
                diapersChanged: 0,
                familiesCalmed: 0,
                alarmsSilenced: 0,
                coffeeConsumed: 0
            },
            // Sprint 5: Tutorial
            tutorial: {
                moveShown: false,
                babyShown: false,
                enemyShown: false,
                sanityShown: false
            },
            tutorialMessage: { text: "", timer: 0, alpha: 0 }
        };

        const keys = {
            w: false, a: false, s: false, d: false,
            up: false, down: false, left: false, right: false
        };

        // Night Shift State
        gameState.flickerTimer = 0;
        gameState.flickerIntensity = 0;

        let entities = [];
        let particles = [];
        let chair = null;
        let isolettes = [];

        const PIXEL_SCALE = 12;
        const COLORS = {
            _: null,
            S: '#f6d0b1',
            B: '#4299e1',
            G: '#48bb78',
            W: '#ffffff',
            H: '#2d3748',
            R: '#f56565',
            P: '#ed64a6',
            Y: '#ecc94b',
            O: '#ed8936',
            L: '#a0aec0',
            D: '#2c5282',
            K: '#000000',
            C: '#0bc5ea',
            N: '#ccff00',
            T: '#d69e2e', // Tan (Dad)
            M: '#742a2a', // Maroon (Floor Cleaner)
            J: '#63b3ed', // Johnny/Gown (Visitor)
        };

        const SPRITES = {
            nurse: [
                "___WWWW___",
                "___WWWW___",
                "___SSSS___",
                "___SRSS___",
                "__BBBBBB__",
                "__BBBBBB__",
                "_BBWWBBBB_",
                "_BBBBBBBB_",
                "__BB__BB__",
                "__NW__NW__"
            ],
            nurse_sit: [
                "____WW____",
                "____SS____",
                "___WWW____",
                "___WWW____",
                "___WWWWWW_",
                "____WW____",
                "____WW____",
                "__________",
                "__________",
                "__________"
            ],
            resident: [
                "___HHHH___", // Hair
                "___SSSS___", // Forehead
                "___SKS____", // Eyes
                "___WWW____", // Mask
                "__WWWWWW__", // Shoulders
                "__C_W_C___", // Steth tubes
                "_WC_W_CW__", // Steth tubes
                "_WWCCCWW__", // Steth U/Bell
                "__WW__WW__", // Legs
                "__WW__WW__"  // Legs
            ],
            surgeon: [
                "___GGGG___",
                "___GGGG___",
                "___SKS____",
                "___GGG____",
                "__GGGGGG__",
                "__GGGGGG__",
                "_GGGGGGGG_",
                "_GGGGGGGG_",
                "__GG__GG__",
                "__GG__GG__"
            ],
            mom: [
                "__HHHHHH__",
                "__HHHHHH__",
                "___SSSS___",
                "__PPPPPP__",
                "__PPPKPP__",
                "_PPPPPPPP_",
                "_PPPPPPPP_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            dad: [
                "__DDDDDD__",
                "___SSSS___",
                "___SSSS___",
                "__DDDDDD__",
                "__DDDYDD__",
                "_DDDDDDDD_",
                "_DDDDDDDD_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            dad_bottle: [
                "__HHHHHH__",
                "___SSSS___",
                "___SSSS___",
                "__TTTTTT__",
                "__TTTWTT__",
                "_TTTTTTTT_",
                "_TWWWWTTT_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            dad_beer: [
                "__HHHHHH__",
                "___SSSS___",
                "__OOOSOO__",
                "__TTTTTT__",
                "__TTTOTT__",
                "_TTTTTTTT_",
                "_TYYYYYTT_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            pizza: [
                "__________",
                "__YYYYY___",
                "_YRRRRRY__",
                "_YRRWRRY__",
                "_YRRRWRY__",
                "_YRRRRRY__",
                "__YYYYY___",
                "__________"
            ],
            admingift: [
                "__________",
                "___RRR____",
                "___RRR____",
                "__PPPPPP__",
                "__PPPPPP__",
                "__PPPPPP__",
                "__PPPPPP__",
                "__________"
            ],
            baby: [
                "__________",
                "____S_____",
                "___WWW____",
                "__WWWWW___",
                "__WWWWW___",
                "___WWW____",
                "__________"
            ],
            coffee: [
                "__________",
                "___SSS____",
                "__________",
                "__WWWW____",
                "__OOOO__W_",
                "__OOOO__W_",
                "__OOOO____",
                "__________"
            ],
            machine_monitor: [
                "__KKKKK___",
                "_KCCC CK__",
                "_KCCC CK__",
                "_KCCC CK__",
                "__KKKKK___",
                "__________",
                "___KKK____",
                "__K__K____"
            ],
            machine_iv: [
                "___K______",
                "___K______",
                "___K______",
                "___K______",
                "__KKK_____",
                "__K_K_____",
                "__K_K_____",
                "__K_K_____"
            ],
            machine_vent: [
                "___KKK____",
                "__KCLCK___",
                "__K_L_K___",
                "__KKKKK___",
                "___K_K____",
                "___K_K____",
                "___K_K____",
                "___K_K____"
            ],
            chair: [
                "___T______",
                "___T______",
                "___T______",
                "___TTTT___",
                "___T__T___",
                "___T__T___",
                "___T__T___",
                "___T__T___"
            ],
            charting: [
                "__________",
                "___KKKK___",
                "___KCCK___",
                "___KKKK___",
                "___TTTT___",
                "___T__T___",
                "___T__T___",
                "___T__T___"
            ]
        };

        // New Sprites for Sprint 1
        Object.assign(SPRITES, {
            floorcleaner: [
                "__________",
                "__KKKKKK__",
                "_KMMMMMK__",
                "_KMMMMMK__",
                "_KMMMMMK__",
                "_KMMMMMK__",
                "__KKKKKK__",
                "___BB_BB__"
            ],
            medicalfamily: [
                "___HHHH___",
                "___SSSS___",
                "___SSSS___",
                "__CCCCCC__", // Lab coat?
                "__C_CC_C__",
                "_CCCCCCCC_",
                "_CCCCCCCC_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            sickvisitor: [
                "___HHHH___",
                "___SGS____", // Green face
                "___SGS____",
                "__JJJJJJ__",
                "__JJKJJJ__",
                "_JJJJJJJJ_",
                "_JJJJJJJJ_",
                "__LL__LL__",
                "__LL__LL__"
            ]
        });

        const SPRITES_ALT = {
            nurse: [
                "____WWWW____",
                "____WWWW____",
                "____SSSS____",
                "____SKSK____", // Added eyes
                "___BBBBBB___",
                "___BBBBBB___",
                "__BBWWWWBB__", // More detail on scrubs
                "__BBBBBBBB__",
                "___BB__BB___",
                "___NW__NW___",
                "___NW__NW___"  // Taller
            ],
            nurse_sit: [
                "_____WW_____",
                "_____SS_____",
                "_____SS_____",
                "____WWWW____",
                "____WWWW____",
                "____WWWWWW__",
                "_____WW_____",
                "_____WW_____",
                "____________",
                "____________",
                "____________",
                "____________"
            ],
            resident: [
                "____HHHH____",
                "____SSSS____",
                "____SKSK____", // Eyes
                "____WWWW____", // Mask
                "___WWWWWW___",
                "___C_WW_C___",
                "__WC_WW_CW__",
                "__WWCCCCWW__",
                "___WW__WW___",
                "___WW__WW___"
            ]
        };

        const nurseResponses = {
            dismissEnemy: [
                "Read the chart!",
                "I'll get back to you",
                "Ask the charge nurse",
                "Not right now",
                "Let me finish this first"
            ],
            feedBaby: [
                "Baby fed.",
                "+15g weight gain",
                "Tolerating feeds well",
                "No residuals!"
            ],
            changeDiaper: [
                "Diaper changed.",
                "Output documented",
                "That was... substantial",
                "Code brown managed"
            ],
            calmBaby: [
                "Baby calmed.",
                "Shhh...",
                "Back to sleep",
                "Crisis averted"
            ]
        };

        const failurePhrases = [
            "I Need a Break",
            "Burnt Out",
            "Can't Even",
            "Done For Today",
            "Need Backup",
            "Mentally Checked Out",
            "Sanity Break Required",
            "I'm Out",
            "Shift Survived... Barely",
            "Emotionally Drained",
            "That's Enough",
            "Tapping Out",
            "Brain.exe Stopped",
            "System Overload",
            "Off The Clock"
        ];

        function drawSprite(ctx, spriteKey, x, y, scale = PIXEL_SCALE, forceAlt = false) {
            let data = SPRITES[spriteKey];
            if ((settings.altSprites || forceAlt) && SPRITES_ALT && SPRITES_ALT[spriteKey]) {
                data = SPRITES_ALT[spriteKey];
            }
            if (!data) return;
            const width = data[0].length * scale;
            const height = data.length * scale;
            const startX = x - width / 2;
            const startY = y - height / 2;

            // Simple drop shadow for all sprites to ground them
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.ellipse(x, y + height / 2 - 2, width / 2, width / 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw Sprite
            for (let r = 0; r < data.length; r++) {
                for (let c = 0; c < data[0].length; c++) {
                    const char = data[r][c];
                    const color = COLORS[char];
                    if (color) {
                        // Main pixel
                        ctx.fillStyle = color;
                        ctx.fillRect(startX + c * scale, startY + r * scale, scale, scale);

                        // Subtle highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        ctx.fillRect(startX + c * scale, startY + r * scale, scale, 2);

                        // Subtle shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        ctx.fillRect(startX + c * scale, startY + r * scale + scale - 2, scale, 2);
                    }
                }
            }
        }

        function addLogEntry(speakerType, message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const hours = Math.floor(gameState.time / 60);
            const mins = Math.min(59, Math.floor(gameState.time % 60)); // FIXED: Prevent 60 minutes
            const timeStr = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;

            let speakerName = "Unknown";
            let speakerClass = "";

            if (speakerType === 'resident') { speakerName = "Res"; speakerClass = "sp-resident"; }
            else if (speakerType === 'mom') { speakerName = "Mom"; speakerClass = "sp-mom"; }
            else if (speakerType === 'dad' || speakerType === 'dad_bottle' || speakerType === 'dad_beer') { speakerName = "Dad"; speakerClass = "sp-dad"; }
            else if (speakerType === 'surgeon') { speakerName = "Surg"; speakerClass = "sp-surgeon"; }
            else if (speakerType === 'nurse') { speakerName = "You"; speakerClass = "sp-nurse"; }
            else if (speakerType === 'admin') { speakerName = "Admin"; speakerClass = "sp-admin"; }
            else if (speakerType === 'baby') { speakerName = "Baby"; speakerClass = "text-white"; }
            // New Types
            else if (speakerType === 'medicalfamily') { speakerName = "Fam"; speakerClass = "sp-mom"; } // Reuse mom color
            else if (speakerType === 'sickvisitor') { speakerName = "Vis"; speakerClass = "text-green-400"; }
            else if (speakerType === 'floorcleaner') { speakerName = "Clean"; speakerClass = "text-gray-500"; }
            else if (speakerType === 'photographer') { speakerName = "Photo"; speakerClass = "text-yellow-200"; }
            else if (speakerType === 'attending') { speakerName = "Attend"; speakerClass = "text-red-400"; }

            entry.innerHTML = `
            <span class="log-time">${timeStr}</span>
            <span class="log-speaker ${speakerClass}">${speakerName}:</span>
            <span class="log-msg">${message}</span>
        `;

            logPanel.prepend(entry);
            if (logPanel.children.length > 50) logPanel.lastElementChild.remove();
        }

        function togglePause() {
            if (gameState.mode !== 'GAME') return;

            gameState.paused = !gameState.paused;

            const sassyPhrases = [
                "Cool it!",
                "Hush!",
                "I can't even.",
                "Unbelievable.",
                "Silence.",
                "Not today.",
                "Excuse you?",
                "I'm on break."
            ];

            if (gameState.paused) {
                gameState.pausePhrase = sassyPhrases[Math.floor(Math.random() * sassyPhrases.length)];
                pauseBtn.innerText = "‚ñ∂ RESUME";
                pauseBtn.style.backgroundColor = "#4299e1";
                pauseBtn.style.color = "#fff";
                pauseBtn.style.borderColor = "#fff";
            } else {
                pauseBtn.innerText = "‚è∏ PAUSE";
                pauseBtn.style.backgroundColor = "";
                pauseBtn.style.color = "";
                pauseBtn.style.borderColor = "";
                gameState.lastTime = performance.now();
            }
        }

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
        }

        class Entity {
            constructor(x, y, type) {
                this.pos = new Vector(x, y);
                this.target = null;
                this.type = type;
                this.size = SPRITES[type] ? SPRITES[type][0].length * PIXEL_SCALE / 2 : 60;
                this.speed = 2;
                this.state = 'idle';
                this.timer = 0;
                this.markedForDeletion = false;
                this.bubble = null;
            }

            update(dt) {
                if (this.state === 'moving' && this.target) {
                    const dx = this.target.x - this.pos.x;
                    const dy = this.target.y - this.pos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.speed) {
                        this.pos.x = this.target.x;
                        this.pos.y = this.target.y;
                        this.state = 'idle';
                        this.onArrive();
                    } else {
                        this.pos.x += (dx / dist) * this.speed;
                        this.pos.y += (dy / dist) * this.speed;
                    }
                }
                if (this.bubble) {
                    this.bubble.life -= dt;
                    if (this.bubble.life <= 0) this.bubble = null;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                this.drawBody(ctx);
                if (this.bubble) {
                    ctx.font = `${20 * (PIXEL_SCALE / 4)}px "Vt323"`;
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const w = ctx.measureText(this.bubble.text).width + 20;
                    ctx.roundRect(-w / 2, -80, w, 40, 5);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.bubble.text, 0, -60);
                }
                ctx.restore();
            }

            drawBody(ctx) { }
            onArrive() { }

            say(text, logSpeakerType = null) {
                this.bubble = { text: text || "...", life: 2000 };
                addLogEntry(logSpeakerType || this.type, text);
            }
        }

        class Nurse extends Entity {
            constructor(x, y) {
                super(x, y, 'nurse');
                this.speed = 4 * (PIXEL_SCALE / 4);
                this.baseSpeed = 4 * (PIXEL_SCALE / 4);
                this.size = SPRITES.nurse[0].length * PIXEL_SCALE / 2;
                this.shieldTimer = 0;
                this.freezeTimer = 0;
            }
            update(dt) {
                // Freeze Logic
                if (this.freezeTimer > 0) {
                    this.freezeTimer -= dt;
                    return; // Don't move or act
                }

                // Keyboard Movement
                if (keys.w || keys.a || keys.s || keys.d || keys.up || keys.down || keys.left || keys.right) {
                    // Cancel sitting state
                    if (this.state === 'sitting') {
                        this.state = 'idle';
                    }

                    // Cancel click-to-move target
                    this.target = null;
                    this.state = 'idle';

                    // Calculate movement vector
                    let dx = 0, dy = 0;
                    if (keys.w || keys.up) dy -= 1;
                    if (keys.s || keys.down) dy += 1;
                    if (keys.a || keys.left) dx -= 1;
                    if (keys.d || keys.right) dx += 1;

                    // Normalize diagonal movement
                    if (dx !== 0 && dy !== 0) {
                        dx *= 0.707;
                        dy *= 0.707;
                    }

                    // Apply movement
                    if (dx !== 0 || dy !== 0) {
                        this.pos.x += dx * this.speed;
                        this.pos.y += dy * this.speed;

                        // Clamp to canvas bounds
                        this.pos.x = Math.max(30, Math.min(canvas.width - 30, this.pos.x));
                        this.pos.y = Math.max(30, Math.min(canvas.height - 30, this.pos.y));

                        this.state = 'walking'; // For animation system (if we had one, but keeps state consistent)
                    }
                }

                // Shield Logic
                if (this.shieldTimer > 0) {
                    this.shieldTimer -= dt;
                }

                if (this.state === 'sitting') {
                    gameState.sanity += 0.15;
                    if (gameState.sanity > 100) gameState.sanity = 100;
                    if (Math.random() < 0.005 && !this.bubble) {
                        this.say("My feet hurt...", 'nurse');
                    }
                    return;
                }
                if (gameState.coffeeBoost > 0) {
                    let speedBoost = 1.8;
                    if (gameState.nightShift) speedBoost = 2.5; // Night shift: stronger coffee
                    this.speed = this.baseSpeed * speedBoost;
                    gameState.coffeeBoost -= dt;
                } else {
                    this.speed = this.baseSpeed;
                }
                super.update(dt);
            }
            draw(ctx) {
                let sprite = 'nurse';
                if (this.state === 'sitting') sprite = 'nurse_sit';

                // Draw Shield Effect
                if (this.shieldTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;
                    ctx.fillStyle = '#4ade80';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#4ade80';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Draw Freeze Effect
                if (this.freezeTimer > 0) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(96, 165, 250, 0.5)';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#60a5fa';
                    ctx.fillRect(this.pos.x - 25, this.pos.y - 45, 50, 90);
                    ctx.restore();
                }

                drawSprite(ctx, sprite, this.pos.x, this.pos.y);

                if (gameState.coffeeBoost > 0 && this.state !== 'sitting') {
                    ctx.fillStyle = '#facc15';
                    ctx.font = `bold ${24 * (PIXEL_SCALE / 4)}px Arial`;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = 'yellow';
                    ctx.fillText('‚ö°', this.pos.x + 15, this.pos.y - 30);
                }
                if (this.bubble) {
                    ctx.font = `${24 * (PIXEL_SCALE / 4)}px "Vt323"`;
                    const w = ctx.measureText(this.bubble.text).width + 20;
                    ctx.fillStyle = '#0f172a';
                    ctx.strokeStyle = '#4ade80';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(this.pos.x - w / 2, this.pos.y - 100, w, 40, 5);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#4ade80';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.bubble.text, this.pos.x, this.pos.y - 75);
                }
            }
        }

        class Isolette extends Entity {
            constructor(x, y, id) {
                super(x, y, 'isolette');
                this.id = id;
                this.needs = [];
                this.needTimer = Math.random() * 5000 + 5000;
                this.size = 15 * (PIXEL_SCALE / 4);
            }
            update(dt) {
                this.needTimer -= dt;
                if (this.needTimer <= 0 && this.needs.length < 3) {
                    const possibleNeeds = ['feed', 'diaper', 'assessment', 'hold', 'procedure', 'photo'];
                    // Weighted random for needs
                    let newNeed = 'feed';
                    const roll = Math.random();
                    if (roll < 0.3) newNeed = 'feed';
                    else if (roll < 0.5) newNeed = 'diaper';
                    else if (roll < 0.65) newNeed = 'assessment';
                    else if (roll < 0.8) newNeed = 'hold';
                    else if (roll < 0.9) newNeed = 'procedure';
                    else newNeed = 'photo';

                    if (!this.needs.includes(newNeed)) {
                        this.needs.push(newNeed);
                        playSoundVisual(this.pos.x, this.pos.y, "ALERT!");
                        playBeep(600, 150);
                    }
                    this.needTimer = Math.random() * 10000 + 10000;
                }
                if (this.needs.length > 0) {
                    let drain = 0.01;
                    if (gameState.shortStaffed) drain *= 1.5; // Short-staffed increases drain
                    if (gameState.nightShift) drain *= 1.2; // Night shift increases drain
                    gameState.sanity -= drain;
                }
            }
            drawBody(ctx) {
                const scaleFactor = PIXEL_SCALE / 6;
                // Add glow if needs present
                if (this.needs.length > 0) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ef4444';
                }

                ctx.fillStyle = '#94a3b8'; ctx.fillRect(-15 * scaleFactor, -8 * scaleFactor, 30 * scaleFactor, 25 * scaleFactor);
                ctx.fillStyle = '#475569'; ctx.fillRect(-15 * scaleFactor, 17 * scaleFactor, 30 * scaleFactor, 4 * scaleFactor);
                ctx.fillStyle = '#e2e8f0'; ctx.beginPath(); ctx.arc(0, -8 * scaleFactor, 18 * scaleFactor, Math.PI, 0); ctx.fill();

                const babyData = SPRITES.baby;
                const babyPixelScale = PIXEL_SCALE / 3;
                const startX = - (babyData[0].length * babyPixelScale) / 2;
                const startY = -12 * scaleFactor;
                for (let r = 0; r < babyData.length; r++) {
                    for (let c = 0; c < babyData[0].length; c++) {
                        if (COLORS[babyData[r][c]]) {
                            ctx.fillStyle = COLORS[babyData[r][c]];
                            ctx.fillRect(startX + c * babyPixelScale, startY + r * babyPixelScale, babyPixelScale, babyPixelScale);
                        }
                    }
                }
                ctx.fillStyle = 'rgba(56, 189, 248, 0.3)'; ctx.beginPath(); ctx.arc(0, -8 * scaleFactor, 18 * scaleFactor, Math.PI, 0); ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1 * scaleFactor; ctx.stroke();

                ctx.shadowBlur = 0; // Reset glow

                ctx.font = `bold ${24 * scaleFactor}px Arial`;
                if (this.needs.includes('feed')) { ctx.fillStyle = '#fef08a'; ctx.fillText('üçº', -10 * scaleFactor, -30 * scaleFactor); }
                if (this.needs.includes('diaper')) { ctx.fillStyle = '#fdba74'; ctx.fillText('üí©', 10 * scaleFactor, -30 * scaleFactor); }
                if (this.needs.includes('assessment')) { ctx.fillStyle = '#fff'; ctx.fillText('üìã', -20 * scaleFactor, -10 * scaleFactor); }
                if (this.needs.includes('hold')) { ctx.fillStyle = '#fbcfe8'; ctx.fillText('ü§±', 20 * scaleFactor, -10 * scaleFactor); }
                if (this.needs.includes('procedure')) { ctx.fillStyle = '#ef4444'; ctx.fillText('üíâ', -10 * scaleFactor, 10 * scaleFactor); }
                if (this.needs.includes('photo')) { ctx.fillStyle = '#e2e8f0'; ctx.fillText('üì∏', 10 * scaleFactor, 10 * scaleFactor); }
            }
        }

        class Machine extends Entity {
            constructor(x, y, type) { super(x, y, type); this.size = 20; }
            drawBody(ctx) {
                // Subtle glow for screens
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#22d3ee';
                drawSprite(ctx, this.type, 0, 0, PIXEL_SCALE / 2);
                ctx.shadowBlur = 0;
            }
            update(dt) { }
        }

        class Enemy extends Entity {
            constructor(x, y, type, targetIsolette) {
                super(x, y, type);
                this.targetIsolette = targetIsolette;

                // Default target (isolette)
                if (targetIsolette) {
                    this.target = new Vector(targetIsolette.pos.x, targetIsolette.pos.y + 40 * (PIXEL_SCALE / 4));
                } else {
                    // For floorcleaner who doesn't target isolettes
                    this.target = new Vector(canvas.width + 100, y);
                }

                this.state = 'moving';
                this.speed = 1.5 * (PIXEL_SCALE / 4);

                // Type specific stats
                if (type === 'surgeon') this.speed = 2.5 * (PIXEL_SCALE / 4);
                if (type === 'floorcleaner') {
                    this.speed = 1.0 * (PIXEL_SCALE / 4);
                    this.target = new Vector(canvas.width + 100, y); // Go straight across
                }

                this.annoyanceLevel = 0;
                this.maxAnnoyance = 100;
                if (type === 'medicalfamily') this.maxAnnoyance = 150;

                this.active = true;
                this.size = SPRITES[type] ? SPRITES[type][0].length * PIXEL_SCALE / 2 : 60;

                // Floor cleaner noise field
                this.noiseTimer = 0;
            }

            onArrive() {
                if (this.type === 'floorcleaner') {
                    this.markedForDeletion = true; // Despawn when reaching other side
                    return;
                }

                this.state = 'annoying';
                let quotes = [];
                if (this.type === 'resident') quotes = ["Is this kid NPO?", "Vein finder?", "Ordering full workup."];
                if (this.type === 'mom') quotes = ["Why is he crying?", "Is that machine beeping?", "I read online..."];
                if (this.type === 'dad' || this.type === 'dad_bottle' || this.type === 'dad_beer') quotes = ["I'm scared.", "Where's the coffee?", "Can I go home?"];
                if (this.type === 'surgeon') quotes = ["NPO. Now.", "Call the Fellow.", "My way or highway."];

                // New Enemy Quotes
                if (this.type === 'medicalfamily') quotes = ["I'm a vet, so...", "WebMD says...", "I took anatomy once."];
                if (this.type === 'sickvisitor') quotes = ["*cough*", "It's just allergies.", "I'm not contagious."];
                if (this.type === 'photographer') quotes = ["Say cheese!", "Just one more!", "Perfect lighting!"];
                if (this.type === 'attending') quotes = ["Why is this not done?", "I'm rounding now.", "Who is the nurse?"];

                this.say(quotes[Math.floor(Math.random() * quotes.length)]);
            }

            leave() {
                this.active = false;
                this.target = new Vector(canvas.width + 50, canvas.height / 2);
                this.state = 'moving';
                this.bubble = null;
                setTimeout(() => { this.markedForDeletion = true; }, 5000);
            }

            update(dt) {
                super.update(dt);

                // Floor Cleaner Logic
                if (this.type === 'floorcleaner') {
                    // Noise field logic
                    if (nurse.pos.dist(this.pos) < 150) {
                        if (nurse.shieldTimer <= 0) { // Check shield
                            gameState.sanity -= 0.2; // High drain
                        }
                        this.noiseTimer += dt;
                        if (this.noiseTimer > 500) {
                            playSoundVisual(this.pos.x, this.pos.y - 40, "RUMBLE");
                            this.noiseTimer = 0;
                        }
                    }
                    return; // Doesn't do normal annoyance
                }

                // Photographer Logic
                if (this.type === 'photographer') {
                    if (Math.random() < 0.01) {
                        // Flash effect
                        playSoundVisual(this.pos.x, this.pos.y, "FLASH!");
                        playBeep(1000, 50);
                        // Wake babies
                        isolettes.forEach(i => {
                            if (Math.random() < 0.3 && i.needs.length === 0) {
                                i.needs.push('calm');
                                addLogEntry('nurse', "Flash woke the baby!");
                            }
                        });
                    }
                }

                // Attending Logic
                if (this.type === 'attending') {
                    if (nurse.pos.dist(this.pos) > 150) {
                        // Must stay close
                        if (nurse.shieldTimer <= 0) {
                            gameState.sanity -= 0.1; // Fast drain if ignored
                        }
                        if (Math.random() < 0.01) addLogEntry('attending', "Where are you going?");
                    } else {
                        // Being near restores a bit or just stops drain
                        gameState.sanity += 0.01;
                    }
                }

                // Sick Visitor Logic
                if (this.type === 'sickvisitor' && this.state === 'annoying') {
                    if (Math.random() < 0.02) {
                        // Sneeze particles
                        for (let i = 0; i < 5; i++) {
                            particles.push({
                                x: this.pos.x,
                                y: this.pos.y - 20,
                                text: '*',
                                color: '#48bb78',
                                life: 40 + Math.random() * 20
                            });
                        }
                        playSoundVisual(this.pos.x, this.pos.y - 40, "*ACHOO*");
                    }
                }

                if (this.state === 'annoying' && this.active) {
                    this.annoyanceLevel += 0.5;
                    let drain = 0.05;
                    if (this.type === 'surgeon') drain = 0.15;
                    if (this.type === 'medicalfamily') drain = 0.08;
                    if (this.type === 'sickvisitor') drain = 0.07;

                    if (nurse.shieldTimer <= 0) { // Check shield
                        gameState.sanity -= drain;
                    }

                    if (this.annoyanceLevel >= this.maxAnnoyance) {
                        if (this.type === 'resident' || this.type === 'surgeon') {
                            playSoundVisual(this.pos.x, this.pos.y, "BABY WOKEN!");
                            this.targetIsolette.needs.push('calm');
                            addLogEntry(this.type, "Whoops, woke the baby.");
                            playBeep(300, 200);
                        } else {
                            addLogEntry(this.type, "I'm going to find the charge nurse.");
                        }
                        this.leave();
                    }
                }
            }

            draw(ctx) {
                drawSprite(ctx, this.type, this.pos.x, this.pos.y);

                // Draw noise field for cleaner
                if (this.type === 'floorcleaner') {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 150, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                if (this.state === 'annoying') {
                    const bw = 30 * (PIXEL_SCALE / 4); const bh = 5 * (PIXEL_SCALE / 4); const by = -50 * (PIXEL_SCALE / 4);
                    // Annoyance bar
                    ctx.fillStyle = '#475569'; ctx.fillRect(this.pos.x - bw / 2, this.pos.y + by, bw, bh);
                    ctx.fillStyle = '#ef4444'; ctx.fillRect(this.pos.x - bw / 2, this.pos.y + by, bw * (this.annoyanceLevel / this.maxAnnoyance), bh);
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(this.pos.x - bw / 2, this.pos.y + by, bw, bh);
                }
                if (this.bubble) {
                    ctx.font = `${20 * (PIXEL_SCALE / 4)}px "Vt323"`;
                    const w = ctx.measureText(this.bubble.text).width + 20;
                    ctx.fillStyle = '#fff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.roundRect(this.pos.x - w / 2, this.pos.y - 100, w, 40, 5); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(this.bubble.text, this.pos.x, this.pos.y - 75);
                }
            }
        }

        class Item extends Entity {
            constructor(x, y, type) {
                super(x, y, type); this.timer = 9000;
                if (type === 'coffee') this.size = SPRITES.coffee[0].length * PIXEL_SCALE / 2;
                else this.size = 30 * (PIXEL_SCALE / 4);
            }
            update(dt) { this.timer -= dt; if (this.timer <= 0) this.markedForDeletion = true; }
            draw(ctx) {
                if (this.type === 'coffee') drawSprite(ctx, 'coffee', this.pos.x, this.pos.y);
                else {
                    ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.font = `${30 * (PIXEL_SCALE / 4)}px Arial`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'white';
                    if (this.type === 'pizza') ctx.fillText('üçï', 0, 0);
                    else if (this.type === 'bathroom') ctx.fillText('üßª', 0, 0);
                    else if (this.type === 'admingift') ctx.fillText('üéÅ', 0, 0);
                    // New Items
                    else if (this.type === 'sanitizer') ctx.fillText('üß¥', 0, 0);
                    else if (this.type === 'workingpump') ctx.fillText('üíâ', 0, 0);
                    else if (this.type === 'coworker') ctx.fillText('üë©‚Äç‚öïÔ∏è', 0, 0);
                    else if (this.type === 'trainingemail') ctx.fillText('üìß', 0, 0);
                    else if (this.type === 'missingsupply') ctx.fillText('‚ùå', 0, 0);
                    else if (this.type === 'brokenequip') ctx.fillText('‚ö†Ô∏è', 0, 0);
                    ctx.restore();
                }
            }
        }

        class ChartingStation extends Entity {
            constructor(x, y) {
                super(x, y, 'charting');
                this.size = 40 * (PIXEL_SCALE / 4);
                this.timer = 30000; // 30 seconds before overdue
                this.maxTimer = 30000;
            }
            drawBody(ctx) {
                drawSprite(ctx, 'charting', 0, 0, PIXEL_SCALE * 1.2);
            }
            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) {
                    gameState.sanity -= 0.05; // Drain when overdue
                    if (Math.random() < 0.01) {
                        addLogEntry('admin', "Documentation overdue!");
                        playBeep(200, 100);
                    }
                }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.pos.x, this.pos.y);

                // Screen glow
                const color = this.timer > 0 ? '#3b82f6' : '#ef4444';
                ctx.fillStyle = color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fillRect(-18, -18, 36, 30);

                ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowBlur = 0;
                ctx.fillText('üíª', 0, -2);

                // Timer bar
                if (this.timer > 0) {
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(-20, -35, 40 * (this.timer / this.maxTimer), 4);
                }
                ctx.restore();
            }
        }

        class SupplyCart extends Entity {
            constructor(x, y) {
                super(x, y, 'supplycart');
                this.size = 40 * (PIXEL_SCALE / 4);
            }
            update(dt) { }
            draw(ctx) {
                ctx.save(); ctx.translate(this.pos.x, this.pos.y);
                ctx.fillStyle = '#f97316';
                ctx.fillRect(-20, -20, 40, 40);
                ctx.strokeStyle = '#c2410c';
                ctx.lineWidth = 2;
                ctx.strokeRect(-20, -20, 40, 40);

                ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('üõí', 0, 0);
                ctx.restore();
            }
        }

        class Pager extends Entity {
            constructor(x, y) {
                super(x, y, 'pager');
                this.size = 30 * (PIXEL_SCALE / 4);
                this.message = null;
                this.timer = 0;
                this.flashState = false;
            }
            update(dt) {
                if (this.message) {
                    this.timer += dt;
                    if (this.timer > 500) {
                        this.flashState = !this.flashState;
                        this.timer = 0;
                        if (this.flashState) playBeep(900, 50);
                    }
                    // Drain sanity if ignored too long
                    gameState.sanity -= 0.005;
                } else {
                    // Random incoming message
                    if (Math.random() < 0.0005) {
                        const msgs = ["Lab: Critical Value", "Family on Line 1", "Pharmacy: Med Clarification", "Charge Nurse: Call me", "RT: Vent Check"];
                        this.message = msgs[Math.floor(Math.random() * msgs.length)];
                        playSoundVisual(this.pos.x, this.pos.y, "BEEP BEEP!");
                    }
                }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.pos.x, this.pos.y);
                ctx.fillStyle = this.message && this.flashState ? '#ef4444' : '#1e293b';
                ctx.fillRect(-15, -25, 30, 50);
                ctx.fillStyle = '#64748b';
                ctx.fillRect(-10, -20, 20, 15); // Screen

                if (this.message) {
                    ctx.fillStyle = 'red';
                    ctx.font = '20px Arial';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'red';
                    ctx.fillText('!', 20, -20);
                }
                ctx.restore();
            }
        }

        class Chair extends Entity {
            constructor(x, y) { super(x, y, 'chair'); }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 25, 20, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                drawSprite(ctx, 'chair', 0, 0, PIXEL_SCALE * 1.2);
                ctx.restore();
            }
        }

        class Sticker {
            constructor(text, color) {
                this.text = text;
                this.color = color;
                this.x = 0;
                this.y = 0;
                this.onMug = false;
                this.angle = 0;
                this.height = 0;
                this.width = 160;
                this.h = 40;
            }
        }

        function initGame() {
            loadSettings(); // Load settings at start of game
            initAudio(); // FIXED: Initialize audio on first user interaction
            gameState.mode = 'GAME';
            resizeCanvas();
            entities = [];
            particles = [];
            isolettes = [];

            // FIXED: Clear log panel completely
            logPanel.innerHTML = '';
            addLogEntry('admin', "SHIFT START. Mandatory huddle skipped.");

            gameState.time = SHIFT_START;
            gameState.sanity = 100;
            gameState.score = 0;
            gameState.gameOver = false;
            gameState.coffeeBoost = 0;
            gameState.paused = false;
            gameState.stickerDelay = 0;
            gameState.displayedScore = 0;
            gameState.mugFillHeight = 0;
            gameState.lastTime = 0; // Reset timing for smooth restart
            // Reset Stats
            gameState.stats = {
                babiesFed: 0,
                diapersChanged: 0,
                familiesCalmed: 0,
                alarmsSilenced: 0,
                coffeeConsumed: 0
            };
            // Reset Tutorial State (if not seen)
            if (!settings.tutorialSeen) {
                gameState.tutorial = {
                    moveShown: false,
                    babyShown: false,
                    enemyShown: false,
                    sanityShown: false
                };
                gameState.tutorialMessage = { text: "", timer: 0, alpha: 0 };
            }
            pauseBtn.innerText = "‚è∏ PAUSE";
            // restartBtn.style.display = 'none'; // Removed
            gameUiTop.style.display = 'flex';
            logPanel.style.display = 'flex';

            // Night Shift is controlled by settings now
            if (gameState.nightShift) {
                addLogEntry('admin', "Night shift protocol active.");
            }

            const cols = 3;
            const rows = 2;
            const startX = canvas.width * 0.15;
            const startY = canvas.height * 0.3;
            const gapX = canvas.width * 0.25;
            const gapY = canvas.height * 0.4;

            // Add Charting Station, Supply Cart, and Pager
            entities.push(new ChartingStation(canvas.width - 60, 60));
            entities.push(new SupplyCart(60, canvas.height - 60));
            entities.push(new Pager(canvas.width - 120, 60)); // Add Pager

            // Initial Spawn
            spawnEnemy();

            let idCount = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const isoX = startX + c * gapX;
                    const isoY = startY + r * gapY;
                    isolettes.push(new Isolette(isoX, isoY, idCount++));
                    const machineType = ['machine_monitor', 'machine_iv', 'machine_vent'][Math.floor(Math.random() * 3)];
                    entities.push(new Machine(isoX + 50, isoY - 20, machineType));
                }
            }
            entities.push(...isolettes);
            chair = new Chair(canvas.width * 0.6, canvas.height * 0.9);
            entities.push(chair);
            const chartingStation = new ChartingStation(canvas.width * 0.6 + 60, canvas.height * 0.9);
            entities.push(chartingStation);
            nurse = new Nurse(canvas.width / 2, canvas.height / 2);
            entities.push(nurse);
        }

        function spawnEnemy() {
            let spawnRate = 0.005;
            if (gameState.shortStaffed) spawnRate *= 1.3; // Increase for short-staffed
            if (Math.random() > spawnRate) return;
            const typeRoll = Math.random();
            let type = 'resident';

            // New Spawn Logic
            // Expanded Spawn Logic
            if (typeRoll < 0.05) type = 'floorcleaner';
            else if (typeRoll < 0.10) type = 'photographer'; // New
            else if (typeRoll < 0.15) type = 'attending'; // New
            else if (typeRoll < 0.35) type = 'resident';
            else if (typeRoll < 0.55) type = 'surgeon';
            else if (typeRoll < 0.75) type = 'medicalfamily';
            else if (typeRoll < 0.85) type = 'sickvisitor';
            else if (Math.random() > 0.5) type = 'mom';
            else type = Math.random() > 0.5 ? 'dad_bottle' : 'dad_beer';

            if (type === 'floorcleaner') {
                // Spawns at left, goes right
                entities.push(new Enemy(-50, canvas.height / 2 + 100, type, null));
            } else {
                const targetIsolette = isolettes[Math.floor(Math.random() * isolettes.length)];
                entities.push(new Enemy(Math.random() > 0.5 ? -50 : canvas.width + 50, Math.random() * canvas.height, type, targetIsolette));
            }
        }

        function spawnItem() {
            if (Math.random() > 0.004) return;
            const roll = Math.random();
            let type = 'coffee';

            // Expanded Item Pool
            if (roll < 0.4) type = 'coffee';
            else if (roll < 0.5) type = 'pizza';
            else if (roll < 0.6) type = 'bathroom';
            else if (roll < 0.7) type = 'admingift';
            // New Items
            else if (roll < 0.75) type = 'sanitizer';
            else if (roll < 0.80) type = 'workingpump';
            else if (roll < 0.85) type = 'coworker';
            else if (roll < 0.90) type = 'trainingemail';
            else if (roll < 0.95) type = 'missingsupply';
            else type = 'brokenequip';

            entities.push(new Item(Math.random() * (canvas.width - 350) + 50, Math.random() * (canvas.height - 100) + 50, type));
        }

        function update(dt) {
            // Night Shift Flicker Logic - REMOVED
            if (gameState.nightShift) {
                gameState.flickerTimer -= dt;
                // Flicker calculation removed
            } else {
                gameState.flickerIntensity = 0;
            }

            if (gameState.mode === 'REPORTOFF') {
                gameState.cutsceneTimer += dt;

                // Incoming nurse walks in
                if (gameState.cutsceneTimer < 2000) {
                    gameState.incomingNursePos.x -= (dt / 1000) * 100; // Move left
                    if (gameState.incomingNursePos.x < canvas.width - 100) gameState.incomingNursePos.x = canvas.width - 100;
                }

                // End cutscene after 6 seconds
                if (gameState.cutsceneTimer > 6000) {
                    gameState.mode = 'MUG';
                }
                return;
            }

            if (gameState.mode === 'MUG') {
                if (gameState.inventoryStickers.length > 0) {
                    gameState.stickerDelay--;
                    if (gameState.stickerDelay <= 0) {
                        const s = gameState.inventoryStickers.shift();

                        // 2D positioning: Bottom to top, constrained to cup
                        const mugH = 500; // Taller cup
                        const mugW = 240; // Top width
                        const mugBaseW = 180; // Bottom width
                        const mugX = canvas.width * 0.58; // Center-right position
                        const mugBottomY = canvas.height / 2 + mugH / 2;

                        // Calculate available width at current height
                        const currentY = mugBottomY - gameState.mugFillHeight - 30;
                        const progress = gameState.mugFillHeight / mugH;
                        const currentWidth = mugBaseW + (mugW - mugBaseW) * progress;

                        // Constrain X to be within the cup at this height
                        // Sticker width is approx 160, so we need to be careful
                        const maxOffset = (currentWidth - 160) / 2;
                        // Clamp offset to ensure it stays inside
                        const randomOffset = (Math.random() * maxOffset * 2) - maxOffset;

                        s.x = mugX + randomOffset;
                        s.y = currentY;
                        s.angle = (Math.random() * 0.1) - 0.05; // Very slight tilt for "lined up" look

                        gameState.mugFillHeight += 45; // Tighter packing
                        gameState.displayedScore += 200; // Animate score

                        gameState.mugStickers.push(s);
                        playSoundVisual(s.x, s.y, "STICKER!");
                        playBeep(800 + Math.random() * 400, 100);
                        gameState.stickerDelay = 20; // Faster placement
                    }
                } else if (gameState.stickerDelay > 0) {
                    gameState.stickerDelay--;
                } else {
                    // restartBtn.style.display = 'block'; // Removed
                }
                return;
            }

            if (!gameState.running || gameState.gameOver) return;

            gameState.time += (dt / MS_PER_GAME_MINUTE);
            if (gameState.time >= SHIFT_END) endGame(true);
            if (gameState.time >= SHIFT_END) endGame(true);
            if (gameState.sanity <= 0) { gameState.sanity = 0; endGame(false); }

            // Simultaneous Alarm Logic
            const alarmedBabies = isolettes.filter(i => i.needs.length > 0).length;
            if (alarmedBabies > 3) {
                gameState.sanity -= 0.05; // Extra drain
                if (Math.random() < 0.02) {
                    playSoundVisual(canvas.width / 2, canvas.height / 2, "ALARM SYMPHONY!");
                    playBeep(800, 300);
                }
            }

            // Random Positive Events (Sprint 5)
            gameState.eventTimer += dt;
            if (gameState.eventTimer > 30000) { // Every 30 seconds
                gameState.eventTimer = 0;
                if (Math.random() < 0.15) { // 15% chance
                    const events = [
                        { msg: "Parent brought cookies!", sanity: 20 },
                        { msg: "All babies sleeping!", sanity: 50 },
                        { msg: "Attending canceled rounds!", sanity: 30 },
                        { msg: "Break nurse showed up!", sanity: 25 }
                    ];
                    const event = events[Math.floor(Math.random() * events.length)];
                    gameState.sanity = Math.min(100, gameState.sanity + event.sanity);
                    addLogEntry('admin', event.msg);
                    playSoundVisual(canvas.width / 2, canvas.height / 2, "GOOD NEWS!");
                    playBeep(1000, 200);
                }
            }

            spawnEnemy();
            spawnItem();

            entities.forEach(e => e.update(dt));
            entities = entities.filter(e => !e.markedForDeletion);

            entities.filter(e => ['coffee', 'pizza', 'bathroom', 'admingift', 'sanitizer', 'workingpump', 'coworker', 'trainingemail', 'missingsupply', 'brokenequip'].includes(e.type)).forEach(item => {
                if (nurse.pos.dist(item.pos) < 40 + item.size / 2 && !item.markedForDeletion) {
                    item.markedForDeletion = true;
                    if (item.type === 'coffee') {
                        gameState.coffeeBoost = 5000;
                        playSoundVisual(item.pos.x, item.pos.y, "CAFFEINE!");
                        gameState.sanity = Math.min(100, gameState.sanity + 5);
                        gameState.stats.coffeeConsumed++; // Track stat
                        addLogEntry('nurse', "Chugged coffee.");
                        playBeep(800, 100);
                    }
                    else if (item.type === 'pizza') {
                        playSoundVisual(item.pos.x, item.pos.y, "Pizza!");
                        gameState.sanity = Math.min(100, gameState.sanity + 20);
                        addLogEntry('nurse', "Cold pizza. Delicious.");
                        playBeep(400, 150);
                    }
                    else if (item.type === 'bathroom') {
                        playSoundVisual(item.pos.x, item.pos.y, "BREAK!");
                        gameState.sanity = Math.min(100, gameState.sanity + 40);
                        addLogEntry('nurse', "Silence. Bliss.");
                        playBeep(500, 200);
                    }
                    else if (item.type === 'admingift') {
                        playSoundVisual(item.pos.x, item.pos.y, "TRAP!");
                        gameState.sanity -= 10;
                        addLogEntry('admin', "Heroes Work Here (rock).");
                        addLogEntry('nurse', "Seriously?!");
                        playBeep(200, 300);
                    }
                    // New Item Effects
                    else if (item.type === 'sanitizer') {
                        playSoundVisual(item.pos.x, item.pos.y, "SHIELD!");
                        gameState.sanity = Math.min(100, gameState.sanity + 15);
                        // addLogEntry('nurse', "Clean hands, clear mind.");
                        nurse.shieldTimer = 3000; // 3 seconds
                        playBeep(600, 150);
                    }
                    else if (item.type === 'workingpump') {
                        playSoundVisual(item.pos.x, item.pos.y, "FIXED!");
                        gameState.sanity = Math.min(100, gameState.sanity + 10);
                        // Auto-fix one isolette
                        const needyIso = isolettes.find(i => i.needs.length > 0);
                        if (needyIso) {
                            needyIso.needs.shift();
                            addLogEntry('nurse', "Pump fixed a problem!");
                        } else {
                            // addLogEntry('nurse', "Equipment actually works!");
                        }
                        playBeep(700, 150);
                    }
                    else if (item.type === 'coworker') {
                        playSoundVisual(item.pos.x, item.pos.y, "HELP!");
                        gameState.sanity = Math.min(100, gameState.sanity + 25);
                        // Dismiss one enemy
                        const annoyingEnemy = entities.find(e => e instanceof Enemy && e.active && e.state === 'annoying');
                        if (annoyingEnemy) {
                            annoyingEnemy.leave();
                            addLogEntry('nurse', "Coworker: I got this one.");
                        } else {
                            addLogEntry('nurse', "Coworker: Just checking in.");
                        }
                        playBeep(800, 150);
                    }
                    else if (item.type === 'trainingemail') {
                        playSoundVisual(item.pos.x, item.pos.y, "DUE NOW!");
                        gameState.sanity -= 20;
                        addLogEntry('admin', "MANDATORY MODULE DUE.");
                        nurse.freezeTimer = 1000; // Freeze for 1s
                        playBeep(150, 400);
                    }
                    else if (item.type === 'missingsupply') {
                        playSoundVisual(item.pos.x, item.pos.y, "EMPTY!");
                        gameState.sanity -= 15;
                        addLogEntry('nurse', "Where are the wipes?!");
                        playBeep(200, 300);
                    }
                    else if (item.type === 'brokenequip') {
                        playSoundVisual(item.pos.x, item.pos.y, "ALARM!");
                        gameState.sanity -= 10;
                        addLogEntry('nurse', "Why is this broken?!");
                        playBeep(800, 500); // Long beep
                    }
                }
            });

            // Charting Station Interaction
            const chartingStation = entities.find(e => e instanceof ChartingStation);
            if (chartingStation && nurse.pos.dist(chartingStation.pos) < 60) {
                if (chartingStation.timer < chartingStation.maxTimer) {
                    chartingStation.timer = Math.min(chartingStation.maxTimer, chartingStation.timer + dt * 2); // Recharge
                    if (chartingStation.timer >= chartingStation.maxTimer) {
                        // addLogEntry('nurse', "Documentation complete.");
                        playSoundVisual(chartingStation.pos.x, chartingStation.pos.y, "SAVED!");
                    }
                }
            }

            // Supply Cart Interaction
            const supplyCart = entities.find(e => e instanceof SupplyCart);
            if (supplyCart && nurse.pos.dist(supplyCart.pos) < 60) {
                // Just a visual interaction for now, maybe add supply count later
                if (Math.random() < 0.01) {
                    // addLogEntry('nurse', "Restocked supplies.");
                }
            }

            // Pager Interaction
            const pager = entities.find(e => e instanceof Pager);
            if (pager && pager.message && nurse.pos.dist(pager.pos) < 60) {
                // Click to clear (simulated by proximity for now, or add click handler later)
                // For now, let's just auto-clear if close enough for 1 second? 
                // No, let's make it instant for better flow
                // addLogEntry('nurse', "Message acknowledged.");
                pager.message = null;
                playSoundVisual(pager.pos.x, pager.pos.y, "CLEARED");
            }

            if (nurse.state === 'idle') {
                isolettes.forEach(iso => {
                    if (nurse.pos.dist(iso.pos) < 50 + iso.size / 2 && iso.needs.length > 0) {
                        const need = iso.needs.shift();
                        if (need === 'feed') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "+15g");
                            gameState.score += 100;
                            gameState.stats.babiesFed++; // Track stat
                            addLogEntry('nurse', nurseResponses.feedBaby[Math.floor(Math.random() * nurseResponses.feedBaby.length)]);
                            playBeep(700, 100);
                        }
                        else if (need === 'diaper') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Clean!");
                            gameState.score += 50;
                            gameState.stats.diapersChanged++; // Track stat
                            addLogEntry('nurse', nurseResponses.changeDiaper[Math.floor(Math.random() * nurseResponses.changeDiaper.length)]);
                            playBeep(650, 100);
                        }
                        else if (need === 'calm') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Shhh...");
                            gameState.score += 20;
                            gameState.stats.alarmsSilenced++; // Track stat
                            addLogEntry('nurse', nurseResponses.calmBaby[Math.floor(Math.random() * nurseResponses.calmBaby.length)]);
                            playBeep(450, 150);
                        }
                        // New Needs
                        else if (need === 'assessment') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Assessed");
                            gameState.score += 150;
                            addLogEntry('nurse', "Assessment complete. Stable.");
                            playBeep(500, 200);
                        }
                        else if (need === 'hold') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Holding...");
                            gameState.score += 75;
                            addLogEntry('nurse', "Parent holding baby.");
                            // Simulate time taken
                            nurse.freezeTimer = 1000;
                            playBeep(400, 300);
                        }
                        else if (need === 'procedure') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Procedure");
                            gameState.sanity -= 5; // Stressful
                            gameState.score += 100;
                            addLogEntry('nurse', "Procedure done. Parents watched.");
                            playBeep(600, 200);
                        }
                        else if (need === 'photo') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Cheese!");
                            gameState.score += 50;
                            addLogEntry('nurse', "Cute photo taken.");
                            playBeep(800, 50);
                        }
                    }
                });
            }

            if (nurse.state === 'idle' && nurse.pos.dist(chair.pos) < 40 + chair.size) {
                nurse.state = 'sitting'; nurse.pos.x = chair.pos.x; nurse.pos.y = chair.pos.y; // addLogEntry('nurse', "Sitting down...");
            }

            if (nurse.state !== 'sitting') {
                entities.filter(e => ['resident', 'mom', 'dad', 'surgeon', 'medicalfamily', 'sickvisitor'].includes(e.type) && e.active && e.state === 'annoying').forEach(enemy => {
                    if (nurse.pos.dist(enemy.pos) < 60 + enemy.size / 2) {
                        // Sick visitor check
                        if (enemy.type === 'sickvisitor' && gameState.sanity < 100) {
                            nurse.say("I can't deal with this right now!");
                            return;
                        }

                        nurse.say(nurseResponses.dismissEnemy[Math.floor(Math.random() * nurseResponses.dismissEnemy.length)]);
                        enemy.leave();

                        let score = 200;
                        if (enemy.type === 'medicalfamily') score = 250;
                        gameState.score += score;
                        gameState.stats.familiesCalmed++; // Track stat

                        playSoundVisual(enemy.pos.x, enemy.pos.y, "Handled.");
                        playBeep(900, 150);
                    }
                });
            }

            // FIXED: Use filter instead of splice in forEach
            particles = particles.filter(p => {
                p.y -= 1;
                p.life--;
                return p.life > 0;
            });

            // Tutorial Logic
            if (!settings.tutorialSeen) {
                // Movement Hint
                if (!gameState.tutorial.moveShown && gameState.time < SHIFT_START + 5) {
                    showTutorial("WASD / Click to Move");
                    gameState.tutorial.moveShown = true;
                }

                // Baby Hint
                if (!gameState.tutorial.babyShown) {
                    const needyIso = isolettes.find(i => i.needs.length > 0);
                    if (needyIso) {
                        showTutorial("Baby Needs Help! Click it!");
                        gameState.tutorial.babyShown = true;
                    }
                }

                // Enemy Hint
                if (!gameState.tutorial.enemyShown) {
                    const enemy = entities.find(e => e instanceof Enemy && e.active && e.state === 'annoying');
                    if (enemy) {
                        showTutorial("Click visitors to dismiss them!");
                        gameState.tutorial.enemyShown = true;
                    }
                }

                // Sanity Hint
                if (!gameState.tutorial.sanityShown && gameState.sanity < 70) {
                    showTutorial("Sanity dropping! Grab coffee!");
                    gameState.tutorial.sanityShown = true;
                }

                // Update Message Timer
                if (gameState.tutorialMessage.timer > 0) {
                    gameState.tutorialMessage.timer -= dt;
                    if (gameState.tutorialMessage.timer < 1000) {
                        gameState.tutorialMessage.alpha = gameState.tutorialMessage.timer / 1000;
                    } else {
                        gameState.tutorialMessage.alpha = 1;
                    }
                } else {
                    gameState.tutorialMessage.alpha = 0;
                }
            }

            // Auto Nurse Mode
            if (settings.autoNurse && nurse.state === 'idle' && !gameState.paused) {
                const target = findNextAutoTarget();
                if (target) {
                    nurse.target = target.pos;
                    nurse.state = 'moving';
                }
            }

            updateHUD(); // FIXED: Moved from draw() to update()
        }

        function findNextAutoTarget() {
            // Priority 1: Babies with needs (feed > diaper > calm > others)
            const needyIsolettes = isolettes.filter(iso => iso.needs.length > 0);
            if (needyIsolettes.length > 0) {
                // Prioritize feed > diaper > calm
                const priority = ['feed', 'diaper', 'calm', 'assessment', 'hold', 'procedure', 'photo'];
                let bestIso = needyIsolettes[0];
                let bestPriority = priority.indexOf(bestIso.needs[0]);

                for (const iso of needyIsolettes) {
                    const p = priority.indexOf(iso.needs[0]);
                    if (p !== -1 && (bestPriority === -1 || p < bestPriority)) {
                        bestIso = iso;
                        bestPriority = p;
                    }
                }
                return { pos: new Vector(bestIso.pos.x, bestIso.pos.y + 30), type: 'baby' };
            }

            // Priority 2: Good items (coffee, pizza, etc.)
            const goodItems = entities.filter(e =>
                ['coffee', 'pizza', 'bathroom', 'sanitizer', 'workingpump', 'coworker'].includes(e.type)
            );
            if (goodItems.length > 0) {
                // Find closest good item
                let closest = goodItems[0];
                let closestDist = nurse.pos.dist(closest.pos);
                for (const item of goodItems) {
                    const d = nurse.pos.dist(item.pos);
                    if (d < closestDist) {
                        closest = item;
                        closestDist = d;
                    }
                }
                return { pos: new Vector(closest.pos.x, closest.pos.y), type: 'item' };
            }

            // Priority 3: Enemies (if annoying)
            const enemies = entities.filter(e =>
                ['resident', 'mom', 'dad', 'surgeon', 'medicalfamily'].includes(e.type) &&
                e.active && e.state === 'annoying'
            );
            if (enemies.length > 0) {
                return { pos: new Vector(enemies[0].pos.x, enemies[0].pos.y), type: 'enemy' };
            }

            // Priority 4: Chair (idle)
            if (chair) {
                return { pos: new Vector(chair.pos.x, chair.pos.y), type: 'chair' };
            }

            return null;
        }

        function drawFloor(ctx) {
            const tileSize = 40;
            const cols = Math.ceil(canvas.width / tileSize);
            const rows = Math.ceil(canvas.height / tileSize);

            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    // Checkered pattern
                    const isEven = (x + y) % 2 === 0;
                    ctx.fillStyle = isEven ? '#1e293b' : '#334155'; // Dark blue-gray checkerboard
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            // Vignette overlay
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.4,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.9
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawNightShiftOverlay() {
            if (!gameState.nightShift) return;

            // Darken the entire screen
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 20, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Vignette effect for night
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.2,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.9
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 30, 0.7)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Flicker effect removed per user request
            // if (gameState.flickerIntensity > 0) {
            //     ctx.fillStyle = `rgba(255, 255, 200, ${gameState.flickerIntensity * 0.02})`;
            //     ctx.fillRect(0, 0, canvas.width, canvas.height);
            // }

            ctx.restore();
        }

        function draw() {
            if (gameState.mode === 'REPORTOFF') {
                drawReportOff();
                return;
            }

            if (gameState.mode === 'MUG') {
                drawMugScreen();
                return;
            }

            // Draw stylized floor first
            drawFloor(ctx);

            entities.sort((a, b) => a.pos.y - b.pos.y);
            entities.forEach(e => e.draw(ctx));

            ctx.font = 'bold 20px Arial';
            particles.forEach(p => {
                ctx.save();
                ctx.shadowBlur = 5;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.fillText(p.text, p.x, p.y);
                ctx.restore();
            });

            drawNightShiftOverlay();
            drawTutorialOverlay();

            if (gameState.paused) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f687b3';
                ctx.font = 'bold 60px "Vt323"';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f687b3';
                ctx.fillText(gameState.pausePhrase, canvas.width / 2, canvas.height / 2);
                ctx.restore();
            }
        }

        function drawMugScreen() {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- LEFT SIDE: STATS ---
            ctx.fillStyle = 'white';
            ctx.font = '60px "Vt323"';
            ctx.textAlign = 'center';
            const title = gameState.victory ? "SHIFT SUMMARY" : gameState.failurePhrase || "SHIFT FAILED";
            const titleColor = gameState.victory ? '#4ade80' : '#ef4444';
            ctx.fillStyle = titleColor;
            ctx.shadowBlur = 10;
            ctx.shadowColor = titleColor;
            ctx.fillText(title, canvas.width * 0.25, 100);
            ctx.shadowBlur = 0;

            ctx.font = '30px "Vt323"';
            ctx.fillStyle = '#94a3b8';
            ctx.textAlign = 'left';
            const startX = canvas.width * 0.25 - 150;
            let y = 200;

            ctx.fillText(`Babies Fed: ${gameState.stats.babiesFed}`, startX, y); y += 50;
            ctx.fillText(`Diapers Changed: ${gameState.stats.diapersChanged}`, startX, y); y += 50;
            ctx.fillText(`Families Calmed: ${gameState.stats.familiesCalmed}`, startX, y); y += 50;
            ctx.fillText(`Alarms Silenced: ${gameState.stats.alarmsSilenced}`, startX, y); y += 50;
            ctx.fillText(`Coffee Consumed: ${gameState.stats.coffeeConsumed}`, startX, y); y += 50;

            ctx.textAlign = 'center';
            ctx.fillStyle = '#facc15';
            ctx.fillText(`Total Score: ${gameState.score}`, canvas.width * 0.25, y + 50);

            // Settings button
            const settingsBtnSize = 60;
            // Box removed per user request
            // ctx.fillStyle = '#334155';
            // ctx.fillRect(canvas.width * 0.25 - settingsBtnSize / 2, y + 100, settingsBtnSize, settingsBtnSize);
            // ctx.strokeStyle = '#475569';
            // ctx.lineWidth = 3;
            // ctx.strokeRect(canvas.width * 0.25 - settingsBtnSize / 2, y + 100, settingsBtnSize, settingsBtnSize);

            ctx.fillStyle = '#475569'; // Darker gray for the icon itself
            ctx.font = '60px "Vt323"'; // Larger font
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öô', canvas.width * 0.25, y + 100 + settingsBtnSize / 2); // Centered vertically
            ctx.textBaseline = 'alphabetic'; // Reset

            // Next Shift Button (Only when ready)
            if (gameState.inventoryStickers.length === 0 && gameState.stickerDelay <= 0) {
                ctx.fillStyle = '#1e40af';
                ctx.fillRect(canvas.width * 0.25 - 100, y + 170, 200, 50);
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.strokeRect(canvas.width * 0.25 - 100, y + 170, 200, 50);
                ctx.fillStyle = '#bfdbfe';
                ctx.font = '24px "Vt323"';
                ctx.textBaseline = 'middle';
                ctx.fillText('NEXT SHIFT >>', canvas.width * 0.25, y + 195); // Centered vertically (170 + 25)
                ctx.textBaseline = 'alphabetic'; // Reset
            }

            // --- RIGHT SIDE: MUG ---
            const mugX = canvas.width * 0.58;
            const mugY = canvas.height / 2;
            const mugW = 240; // Wider top
            const mugBaseW = 180; // Narrower bottom
            const mugH = 500; // Taller cup

            // Draw Shadow/Outline Cup
            ctx.save();
            ctx.translate(mugX, mugY);

            // Cup Shape Path
            ctx.beginPath();
            ctx.moveTo(-mugW / 2, -mugH / 2);
            ctx.lineTo(mugW / 2, -mugH / 2);
            ctx.lineTo(mugBaseW / 2, mugH / 2);
            ctx.lineTo(-mugBaseW / 2, mugH / 2);
            ctx.closePath();

            // Fill with shadow color
            ctx.fillStyle = '#1e293b';
            ctx.fill();

            // Outline
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Straw (optional detail)
            ctx.fillStyle = '#60a5fa';
            ctx.fillRect(20, -mugH / 2 - 80, 20, 100);

            ctx.restore();

            // Draw Stickers
            gameState.mugStickers.forEach(s => {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);

                // Sticker Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(-s.width / 2 + 4, -s.h / 2 + 4, s.width, s.h, 5);
                ctx.fill();

                // Sticker Body
                ctx.fillStyle = s.color;
                ctx.beginPath();
                ctx.roundRect(-s.width / 2, -s.h / 2, s.width, s.h, 5);
                ctx.fill();

                // Sticker Outline
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Text
                ctx.fillStyle = 'black';
                ctx.font = '20px "Vt323"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(s.text, 0, 0);

                ctx.restore();
            });

            // Draw Score (Mug Side)
            ctx.fillStyle = 'white';
            ctx.font = '60px "Vt323"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'white';
            ctx.fillText(`SCORE: ${gameState.displayedScore}`, mugX, 100);

            if (gameState.inventoryStickers.length === 0 && gameState.stickerDelay <= 0) {
                ctx.fillStyle = '#4ade80';
                ctx.font = '40px "Vt323"';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#4ade80';
                ctx.fillText("SHIFT COMPLETE", mugX, canvas.height - 50);
            }
        }

        function drawSticker(s) {
            ctx.save();
            ctx.translate(s.x, s.y);

            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.roundRect(-s.width / 2, -s.h / 2, s.width, s.h, 5);
            ctx.fill();

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = 'black';
            ctx.font = '24px "Vt323"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(s.text, 0, 0);

            ctx.restore();
        }

        function drawTutorialOverlay() {
            if (gameState.tutorialMessage.alpha <= 0) return;

            ctx.save();
            ctx.globalAlpha = gameState.tutorialMessage.alpha;
            ctx.fillStyle = 'rgba(15, 23, 42, 0.9)';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#000';
            ctx.roundRect(canvas.width / 2 - 300, 100, 600, 60, 10);
            ctx.fill();

            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#60a5fa';
            ctx.font = '30px "Vt323"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(gameState.tutorialMessage.text, canvas.width / 2, 130);
            ctx.restore();
        }

        function showTutorial(text) {
            gameState.tutorialMessage.text = text;
            gameState.tutorialMessage.timer = 5000; // Show for 5 seconds
            gameState.tutorialMessage.alpha = 1;
        }

        function drawReportOff() {
            // Draw floor
            drawFloor(ctx);

            // Draw Player Nurse (Idle)
            drawSprite(ctx, 'nurse', nurse.pos.x, nurse.pos.y);

            // Draw Incoming Nurse
            drawSprite(ctx, 'nurse', gameState.incomingNursePos.x, gameState.incomingNursePos.y);

            // Dialogue
            ctx.font = '24px "Vt323"';
            ctx.textAlign = 'center';

            if (gameState.cutsceneTimer > 2000 && gameState.cutsceneTimer < 4000) {
                // Incoming Nurse speaks
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(gameState.incomingNursePos.x - 60, gameState.incomingNursePos.y - 100, 120, 60, 5);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.fillText("I'm here!", gameState.incomingNursePos.x, gameState.incomingNursePos.y - 60);
            } else if (gameState.cutsceneTimer > 4000 && gameState.cutsceneTimer < 6000) {
                // Player Nurse speaks
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(nurse.pos.x - 60, nurse.pos.y - 100, 120, 60, 5);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'black';

                const text = gameState.victory ? "All yours." : "I'm done.";
                ctx.fillText(text, nurse.pos.x, nurse.pos.y - 60);
            }
        }

        function updateHUD() {
            const hours = Math.floor(gameState.time / 60);
            const mins = Math.min(59, Math.floor(gameState.time % 60)); // FIXED: Prevent 60 minutes
            timerDisplay.innerText = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            scoreDisplay.innerText = gameState.score;

            // Update sanity width and color
            const width = Math.max(0, gameState.sanity);
            sanityBar.style.width = `${width}%`;
            sanityPercent.innerText = `${Math.floor(width)}%`;

            if (width > 50) {
                sanityBar.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                sanityBar.style.boxShadow = '0 0 10px #22c55e';
                sanityPercent.className = 'text-sm text-green-400';
            }
            else if (width > 20) {
                sanityBar.style.background = 'linear-gradient(90deg, #ca8a04, #facc15)';
                sanityBar.style.boxShadow = '0 0 10px #facc15';
                sanityPercent.className = 'text-sm text-yellow-400';
            }
            else {
                sanityBar.style.background = 'linear-gradient(90deg, #991b1b, #ef4444)';
                sanityBar.style.boxShadow = '0 0 10px #ef4444';
                sanityPercent.className = 'text-sm text-red-400 blink';
            }
        }

        function playSoundVisual(x, y, text) {
            particles.push({ x: x, y: y - 20, text: text, color: '#fff', life: 60 });
        }

        function loop(timestamp) {
            if (!gameState.paused) {
                const dt = timestamp - gameState.lastTime;
                gameState.lastTime = timestamp;
                update(dt);
            }
            draw();
            if (gameState.running) requestAnimationFrame(loop);
        }

        function startGame() {
            modalOverlay.style.display = 'none';
            initGame();
            gameState.running = true;
            gameState.lastTime = performance.now();
            requestAnimationFrame(loop);
            showMessage("Shift Start!");
        }

        function endGame(victory) {
            gameState.victory = victory; // Store for summary title

            if (victory) {
                gameState.mode = 'REPORTOFF';
                gameState.cutsceneTimer = 0;
                gameState.incomingNursePos = { x: canvas.width + 50, y: canvas.height / 2 };
            } else {
                gameState.mode = 'MUG';
                // Select random failure phrase
                gameState.failurePhrase = failurePhrases[Math.floor(Math.random() * failurePhrases.length)];
            }

            gameUiTop.style.display = 'none';
            // Only hide log panel on victory (successful shift)
            if (victory) {
                logPanel.style.display = 'none';
            }
            messageBox.style.opacity = 0;
            // restartBtn.style.display = 'none'; // Removed

            // Set tutorial as seen after first game ends
            settings.tutorialSeen = true;

            // Prepare stickers for Mug screen (logic remains same)
            const stickerPhrases = [
                // Original phrases
                "Tiny Dictator", "NPO means NO", "Coffee IV", "Chart This",
                "Screaming Potato", "Vein Whisperer", "Chaos Coordinator",
                "Nap Time?", "Code Brown", "Shhh!", "Tired.", "Nope.",
                // Sprint 5: New phrases
                "Hand Hygiene Queen", "Alarm Silencer", "NPO Enforcer",
                "No Flash Photos", "I Need Backup", "Intake/Output",
                "15 Minute Chart", "Family Education", "Code Brown Survivor",
                "Tandem Nursing", "Skin-to-Skin", "Beep Beep Beep",
                "Where's RT?", "Call the Fellow", "Not My Patient",
                "I Forgot to Chart", "Pizza Party?", "Mandatory Training",
                "Float Pool", "Short Staffed"
            ];
            const colors = ['#fca5a5', '#fcd34d', '#86efac', '#67e8f9', '#93c5fd', '#d8b4fe'];

            const count = Math.max(1, Math.floor(gameState.score / 200));

            gameState.inventoryStickers = [];
            gameState.displayedScore = 0; // Reset displayed score
            gameState.mugFillHeight = 0; // Reset fill height

            for (let i = 0; i < count; i++) {
                const txt = stickerPhrases[Math.floor(Math.random() * stickerPhrases.length)];
                const col = colors[Math.floor(Math.random() * colors.length)];
                const s = new Sticker(txt, col);
                // No x/y needed for inventory anymore
                gameState.inventoryStickers.push(s);
            }
            gameState.mugStickers = [];
            gameState.stickerDelay = 60; // Initial delay
        }

        // Global error handler
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            const errorMsg = `Error: ${msg} at line ${lineNo}`;
            console.error(errorMsg);
            // Try to log to game panel if possible
            try {
                if (logPanel) {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.style.color = 'red';
                    entry.innerText = errorMsg;
                    logPanel.prepend(entry);
                }
            } catch (e) { }
            return false;
        };

        function showMessage(text) {
            messageText.innerText = text;
            messageBox.style.display = 'block';
            // Force reflow
            void messageBox.offsetWidth;
            messageBox.style.opacity = 1;

            setTimeout(() => {
                messageBox.style.opacity = 0;
                setTimeout(() => {
                    if (messageBox.style.opacity === '0') {
                        messageBox.style.display = 'none';
                    }
                }, 500); // Wait for transition
            }, 3000);
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function handlePointerDown(e) {
            // Allow clicks on canvas OR the container (in case of letterboxing)
            const isCanvas = e.target === canvas;
            const isContainer = e.target.id === 'game-container';

            if (!isCanvas && !isContainer) return;

            const pos = getMousePos(e);

            if (gameState.mode === 'MUG') {
                // Check for Settings button click (left side, below stats)
                const statsY = 200 + (5 * 50); // 5 stat lines * 50px each
                const settingsBtnSize = 60;
                const settingsBtnX = canvas.width * 0.25 - settingsBtnSize / 2;
                const settingsBtnY = statsY + 100;
                const settingsBtnW = settingsBtnSize;
                const settingsBtnH = settingsBtnSize;

                if (pos.x > settingsBtnX && pos.x < settingsBtnX + settingsBtnW &&
                    pos.y > settingsBtnY && pos.y < settingsBtnY + settingsBtnH) {
                    openSettings();
                    return;
                }

                // Check for Next Shift button click
                const nextShiftBtnY = statsY + 170;
                // The next shift button still uses the old width (200) and is centered at canvas.width * 0.25
                const nextShiftBtnX = canvas.width * 0.25 - 100;
                const nextShiftBtnW = 200;
                const nextShiftBtnH = 50;

                if (pos.x > nextShiftBtnX && pos.x < nextShiftBtnX + nextShiftBtnW &&
                    pos.y > nextShiftBtnY && pos.y < nextShiftBtnY + nextShiftBtnH) {
                    if (gameState.inventoryStickers.length === 0 && gameState.stickerDelay <= 0) {
                        startGame();
                    }
                    return;
                }
                return;
            }

            if (gameState.mode === 'REPORTOFF') return;

            if (!gameState.running || gameState.paused) return;

            particles.push({ x: pos.x, y: pos.y, text: '.', color: '#fff', life: 10 });

            if (nurse.state === 'sitting') {
                nurse.state = 'moving'; nurse.target = new Vector(pos.x, pos.y);
                nurse.say("Back to work...", 'nurse');
                return;
            }

            const items = entities.filter(ent => ['coffee', 'pizza', 'bathroom', 'admingift'].includes(ent.type));
            for (let item of items) {
                // FIXED: Check if CLICK is on item, not if nurse is close
                if (item.pos.dist(pos) < 40 + item.size / 2) {
                    nurse.target = new Vector(item.pos.x, item.pos.y); nurse.state = 'moving'; return;
                }
            }
            const enemies = entities.filter(ent => ['resident', 'mom', 'dad', 'surgeon'].includes(ent.type) && ent.active);
            for (let enemy of enemies) {
                // FIXED: Check if CLICK is on enemy
                if (enemy.pos.dist(pos) < 40 + enemy.size / 2) {
                    nurse.target = new Vector(enemy.pos.x, enemy.pos.y); nurse.state = 'moving'; return;
                }
            }
            for (let iso of isolettes) {
                // FIXED: Check if CLICK is on isolette
                if (iso.pos.dist(pos) < 40 + iso.size / 2) {
                    nurse.target = new Vector(iso.pos.x, iso.pos.y + 30); nurse.state = 'moving'; return;
                }
            }
            // Chair check was already using pos.dist, but let's be consistent
            if (chair.pos.dist(pos) < 40 + chair.size) {
                nurse.target = new Vector(chair.pos.x, chair.pos.y);
                nurse.state = 'moving';
                return;
            }

            nurse.target = new Vector(pos.x, pos.y);
            nurse.state = 'moving';
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('mousedown', handlePointerDown);
        window.addEventListener('touchstart', (e) => {
            if (e.target === canvas || e.target.id === 'game-container') {
                e.preventDefault(); // Prevent mouse emulation only on canvas/container
                handlePointerDown(e.touches[0]);
            }
        }, { passive: false });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = true;
            if (key === 'a' || key === 'arrowleft') keys.a = true;
            if (key === 's' || key === 'arrowdown') keys.s = true;
            if (key === 'd' || key === 'arrowright') keys.d = true;
            if (key === 'arrowup') keys.up = true;
            if (key === 'arrowdown') keys.down = true;
            if (key === 'arrowleft') keys.left = true;
            if (key === 'arrowright') keys.right = true;
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = false;
            if (key === 'a' || key === 'arrowleft') keys.a = false;
            if (key === 's' || key === 'arrowdown') keys.s = false;
            if (key === 'd' || key === 'arrowright') keys.d = false;
            if (key === 'arrowup') keys.up = false;
            if (key === 'arrowdown') keys.down = false;
            if (key === 'arrowleft') keys.left = false;
            if (key === 'arrowright') keys.right = false;
        });

        resizeCanvas();
    </script>
</body>

</html>