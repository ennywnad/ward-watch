<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shift Goals: NICU Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vt323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #2d3748;
            font-family: 'Vt323', monospace;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
        }

        canvas {
            background-color: #e2e8f0;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            pointer-events: auto;
            font-size: 1.5rem;
            border: 4px solid #4a5568;
            white-space: nowrap;
            box-shadow: 4px 4px 0px #000;
        }

        .pause-btn {
            background: #e53e3e;
            border-color: #9b2c2c;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .pause-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }

        .mug-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: #3182ce;
            color: white;
            border: 4px solid #2c5282;
            padding: 10px 20px;
            font-size: 1.5rem;
            font-family: 'Vt323', monospace;
            cursor: pointer;
            box-shadow: 6px 6px 0px #000;
            pointer-events: auto;
            display: none;
            z-index: 50;
        }

        .mug-btn:hover {
            background: #2b6cb0;
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0px #000;
        }

        #sanity-bar-container {
            width: 200px;
            height: 20px;
            background: #2d3748;
            border: 2px solid #fff;
            margin-top: 5px;
        }

        #sanity-bar {
            width: 100%;
            height: 100%;
            background: #48bb78;
            transition: width 0.2s, background 0.2s;
        }

        #log-panel {
            position: absolute;
            right: 10px;
            top: 90px;
            bottom: 10px;
            width: 320px;
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(113, 128, 150, 0.5);
            border-radius: 4px;
            padding: 8px;
            overflow-y: auto;
            pointer-events: none;
            font-family: 'Vt323', monospace;
            display: flex;
            flex-direction: column-reverse;
        }

        #log-panel::-webkit-scrollbar {
            display: none;
        }

        #log-panel {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .log-entry {
            margin-bottom: 6px;
            border-bottom: 1px solid rgba(74, 85, 104, 0.5);
            padding-bottom: 4px;
            line-height: 1.1;
            text-shadow: 2px 2px 0 #000;
        }

        .log-time {
            color: #a0aec0;
            font-size: 0.9rem;
            margin-right: 4px;
        }

        .log-speaker {
            font-weight: bold;
            margin-right: 4px;
            font-size: 1.1rem;
        }

        .log-msg {
            font-size: 1.1rem;
            color: #e2e8f0;
        }

        .sp-resident {
            color: #90cdf4;
        }

        .sp-mom {
            color: #f687b3;
        }

        .sp-dad {
            color: #63b3ed;
        }

        .sp-surgeon {
            color: #fc8181;
        }

        .sp-nurse {
            color: #68d391;
        }

        .sp-admin {
            color: #d6bcfa;
        }

        #modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .modal-content {
            background: #2d3748;
            color: white;
            padding: 2rem;
            border-radius: 0px;
            text-align: center;
            border: 4px solid #fff;
            box-shadow: 8px 8px 0px #000;
            max-width: 600px;
        }

        .btn {
            background: #3182ce;
            color: white;
            border: 4px solid #2c5282;
            padding: 10px 20px;
            font-size: 1.5rem;
            font-family: 'Vt323', monospace;
            cursor: pointer;
            margin-top: 1rem;
            box-shadow: 4px 4px 0px #000;
        }

        .btn:hover {
            background: #2b6cb0;
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0px #000;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }

        #settings-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 150;
            pointer-events: auto;
        }

        #settings-overlay input[type="range"] {
            cursor: pointer;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div class="flex justify-between w-full items-start" id="game-ui-top">
                <div class="hud-panel">
                    <div>TIME: <span id="timer">07:00</span></div>
                    <div>SCORE: <span id="score">0</span></div>
                </div>

                <button id="pause-btn" class="hud-panel pause-btn" onclick="togglePause()">
                    ‚è∏ PAUSE
                </button>

                <div class="hud-panel" id="sanity-container-ui">
                    <div>SANITY</div>
                    <div id="sanity-bar-container">
                        <div id="sanity-bar"></div>
                    </div>
                </div>
            </div>

            <div id="log-panel">
                <div class="log-entry"><span class="log-time">07:00</span> <span class="log-msg text-gray-400">Shift
                        started. Good luck.</span></div>
            </div>

            <div class="hud-panel self-center" id="message-box" style="opacity: 0; transition: opacity 0.5s;">
                <span id="message-text">Shift Started!</span>
            </div>

            <button id="restart-btn" class="mug-btn" onclick="startGame()">NEXT SHIFT</button>
        </div>

        <div id="modal-overlay">
            <div class="modal-content">
                <h1 class="text-4xl mb-4 text-blue-300">SHIFT GOALS</h1>
                <p class="text-xl mb-4">NICU Edition</p>
                <div class="grid grid-cols-2 gap-4 text-left text-lg mb-6">
                    <div>
                        <h3 class="text-green-400 font-bold">GOOD STUFF</h3>
                        <ul class="space-y-1">
                            <li>‚òï <strong>Coffee:</strong> Speed Boost</li>
                            <li>üçï <strong>Pizza:</strong> Food! (+Sanity)</li>
                            <li>üßª <strong>Break:</strong> Max Sanity</li>
                            <li>ü™ë <strong>Chair:</strong> Sit to heal.</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-red-400 font-bold">BAD STUFF</h3>
                        <ul class="space-y-1">
                            <li>üò∑ <strong>Surgeon:</strong> Arrogant</li>
                            <li>üë®‚Äç‚öïÔ∏è <strong>Resident:</strong> Clueless</li>
                            <li>üéÅ <strong>Admin:</strong> "Wellness" Traps</li>
                        </ul>
                    </div>
                </div>
                <p class="text-md italic mb-4 text-gray-400">"Earn stickers for your big dumb mug!"</p>
                <button class="btn" onclick="startGame()">CLOCK IN</button>
                <button class="btn" onclick="openSettings()" style="margin-top: 0.5rem; background: #718096;">
                    ‚öô SETTINGS
                </button>
            </div>
        </div>

        <div id="settings-overlay" style="display: none;">
            <div class="modal-content" style="max-width: 400px;">
                <h2 class="text-3xl mb-4 text-blue-300">SETTINGS</h2>

                <div class="text-left space-y-4">
                    <div class="flex justify-between items-center">
                        <label>Volume</label>
                        <input type="range" id="volume-slider" min="0" max="100" value="50" class="w-32"
                            onchange="updateVolume(this.value)">
                    </div>

                    <div class="flex justify-between items-center">
                        <label>Night Shift Mode</label>
                        <button id="night-toggle" class="btn text-sm py-1" onclick="toggleNightShift()">
                            OFF
                        </button>
                    </div>

                    <div class="flex justify-between items-center">
                        <label>Short Staffed Mode</label>
                        <button id="staff-toggle" class="btn text-sm py-1" onclick="toggleShortStaffed()">
                            OFF
                        </button>
                    </div>

                    <div class="flex justify-between items-center">
                        <label>Reset Tutorial</label>
                        <button class="btn text-sm py-1" onclick="resetTutorial()">
                            RESET
                        </button>
                    </div>
                </div>

                <button class="btn mt-6" onclick="closeSettings()">DONE</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const sanityBar = document.getElementById('sanity-bar');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.querySelector('.modal-content');
        const logPanel = document.getElementById('log-panel');
        const pauseBtn = document.getElementById('pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const gameUiTop = document.getElementById('game-ui-top');

        const SHIFT_START = 7 * 60;
        const SHIFT_END = 19 * 60;
        const GAME_DURATION_SECONDS = 140;
        const MS_PER_GAME_MINUTE = (GAME_DURATION_SECONDS * 1000) / (12 * 60);

        // Audio context for sound effects
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playBeep(frequency = 440, duration = 100) {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.frequency.value = frequency;
                gainNode.gain.setValueAtTime(0.3 * settings.volume, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration / 1000);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + duration / 1000);
            } catch (e) {
                // Audio failed, no big deal
            }
        }



        const settings = {
            volume: 0.5,
            nightShift: false,
            shortStaffed: false,
            tutorialSeen: false
        };

        // Load from localStorage on page load
        function loadSettings() {
            const saved = localStorage.getItem('nicuSettings');
            if (saved) {
                Object.assign(settings, JSON.parse(saved));
                gameState.nightShift = settings.nightShift;
                gameState.shortStaffed = settings.shortStaffed;
            }
            updateSettingsUI();
        }

        function saveSettings() {
            localStorage.setItem('nicuSettings', JSON.stringify(settings));
        }

        function openSettings() {
            document.getElementById('settings-overlay').style.display = 'flex';
            updateSettingsUI();
        }

        function closeSettings() {
            document.getElementById('settings-overlay').style.display = 'none';
            saveSettings();
        }

        function updateSettingsUI() {
            const volSlider = document.getElementById('volume-slider');
            if (volSlider) volSlider.value = settings.volume * 100;

            const nightBtn = document.getElementById('night-toggle');
            if (nightBtn) {
                nightBtn.innerText = settings.nightShift ? 'ON' : 'OFF';
                nightBtn.style.background = settings.nightShift ? '#48bb78' : '#e53e3e';
            }

            const staffBtn = document.getElementById('staff-toggle');
            if (staffBtn) {
                staffBtn.innerText = settings.shortStaffed ? 'ON' : 'OFF';
                staffBtn.style.background = settings.shortStaffed ? '#48bb78' : '#e53e3e';
            }
        }

        function updateVolume(val) {
            settings.volume = val / 100;
        }

        function toggleNightShift() {
            settings.nightShift = !settings.nightShift;
            gameState.nightShift = settings.nightShift;
            updateSettingsUI();
        }

        function toggleShortStaffed() {
            settings.shortStaffed = !settings.shortStaffed;
            gameState.shortStaffed = settings.shortStaffed;
            updateSettingsUI();
        }

        function resetTutorial() {
            settings.tutorialSeen = false;
            saveSettings();
            alert('Tutorial will show on next shift!');
        }

        let gameState = {
            mode: 'MENU',
            running: false,
            paused: false,
            pausePhrase: "PAUSED",
            time: SHIFT_START,
            sanity: 100,
            score: 0,
            lastTime: 0,
            coffeeBoost: 0,
            mugStickers: [],
            inventoryStickers: [],
            stickerDelay: 0,
            displayedScore: 0,
            mugFillHeight: 0,
            // Sprint 5: Difficulty modifiers
            shortStaffed: false,
            nightShift: false,
            eventTimer: 0,
            // Sprint 5: Stats
            stats: {
                babiesFed: 0,
                diapersChanged: 0,
                familiesCalmed: 0,
                alarmsSilenced: 0,
                coffeeConsumed: 0
            },
            // Sprint 5: Tutorial
            tutorial: {
                moveShown: false,
                babyShown: false,
                enemyShown: false,
                sanityShown: false
            },
            tutorialMessage: { text: "", timer: 0, alpha: 0 }
        };

        const keys = {
            w: false, a: false, s: false, d: false,
            up: false, down: false, left: false, right: false
        };

        // Night Shift State
        gameState.flickerTimer = 0;
        gameState.flickerIntensity = 0;

        let entities = [];
        let particles = [];
        let chair = null;
        let isolettes = [];

        const PIXEL_SCALE = 12;
        const COLORS = {
            _: null,
            S: '#f6d0b1',
            B: '#4299e1',
            G: '#48bb78',
            W: '#ffffff',
            H: '#2d3748',
            R: '#f56565',
            P: '#ed64a6',
            Y: '#ecc94b',
            O: '#ed8936',
            L: '#a0aec0',
            D: '#2c5282',
            K: '#000000',
            C: '#0bc5ea',
            N: '#ccff00',
        };

        const SPRITES = {
            nurse: [
                "___WWWW___",
                "___WWWW___",
                "___SSSS___",
                "___SRSS___",
                "__BBBBBB__",
                "__BBBBBB__",
                "_BBWWBBBB_",
                "_BBBBBBBB_",
                "__BB__BB__",
                "__NW__NW__"
            ],
            nurse_sit: [
                "___WWWW___",
                "___WWWW___",
                "___SSSS___",
                "___SRSS___",
                "__BBBBBB__",
                "__BBBBBB__",
                "_BBBBBB___",
                "_BBBBBB___",
                "__BB______",
                "__NW______"
            ],
            resident: [
                "___HHHH___",
                "___SSSS___",
                "___SSSS___",
                "__WWWWWW__",
                "__WWLWWW__",
                "_WWWDDWWW_",
                "_WWWWWWWW_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            surgeon: [
                "___GGGG___",
                "___GGGG___",
                "___SKS____",
                "___GGG____",
                "__GGGGGG__",
                "__GGGGGG__",
                "_GGGGGGGG_",
                "_GGGGGGGG_",
                "__GG__GG__",
                "__GG__GG__"
            ],
            mom: [
                "__HHHHHH__",
                "__HHHHHH__",
                "___SSSS___",
                "__PPPPPP__",
                "__PPPKPP__",
                "_PPPPPPPP_",
                "_PPPPPPPP_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            dad: [
                "__DDDDDD__",
                "___SSSS___",
                "___SSSS___",
                "__DDDDDD__",
                "__DDDYDD__",
                "_DDDDDDDD_",
                "_DDDDDDDD_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            baby: [
                "__________",
                "____S_____",
                "___WWW____",
                "__WWWWW___",
                "__WWWWW___",
                "___WWW____",
                "__________"
            ],
            coffee: [
                "__________",
                "___SSS____",
                "__________",
                "__WWWW____",
                "__OOOO__W_",
                "__OOOO__W_",
                "__OOOO____",
                "__________"
            ],
            machine_monitor: [
                "__KKKKK___",
                "_KCCC CK__",
                "_KCCC CK__",
                "_KCCC CK__",
                "__KKKKK___",
                "__________",
                "___KKK____",
                "__K__K____"
            ],
            machine_iv: [
                "___K______",
                "___K______",
                "___K______",
                "___K______",
                "__KKK_____",
                "__K_K_____",
                "__K_K_____",
                "__K_K_____"
            ],
            machine_vent: [
                "___KKK____",
                "__KCLCK___",
                "__K_L_K___",
                "__KKKKK___",
                "___K_K____",
                "___K_K____",
                "___K_K____",
                "___K_K____"
            ]
        };

        // New Sprites for Sprint 1
        Object.assign(SPRITES, {
            floorcleaner: [
                "___MMMM___",
                "__MMMMMM__",
                "__M_WW_M__",
                "__MMMMMM__",
                "_MMMMMMMM_",
                "_MMMMMMMM_",
                "__BB__BB__",
                "__BB__BB__"
            ],
            medicalfamily: [
                "___HHHH___",
                "___SSSS___",
                "___SSSS___",
                "__CCCCCC__", // Lab coat?
                "__C_CC_C__",
                "_CCCCCCCC_",
                "_CCCCCCCC_",
                "__LL__LL__",
                "__LL__LL__"
            ],
            sickvisitor: [
                "___HHHH___",
                "___SGS____", // Green face
                "___SGS____",
                "__JJJJJJ__",
                "__JJKJJJ__",
                "_JJJJJJJJ_",
                "_JJJJJJJJ_",
                "__LL__LL__",
                "__LL__LL__"
            ]
        });

        const nurseResponses = {
            dismissEnemy: [
                "Read the chart!",
                "I'll get back to you",
                "Ask the charge nurse",
                "Not right now",
                "Let me finish this first"
            ],
            feedBaby: [
                "Baby fed.",
                "+15g weight gain",
                "Tolerating feeds well",
                "No residuals!"
            ],
            changeDiaper: [
                "Diaper changed.",
                "Output documented",
                "That was... substantial",
                "Code brown managed"
            ],
            calmBaby: [
                "Baby calmed.",
                "Shhh...",
                "Back to sleep",
                "Crisis averted"
            ]
        };

        function drawSprite(ctx, spriteKey, x, y, scale = PIXEL_SCALE) {
            const data = SPRITES[spriteKey];
            if (!data) return;
            const width = data[0].length * scale;
            const height = data.length * scale;
            const startX = x - width / 2;
            const startY = y - height / 2;

            if (!spriteKey.startsWith('machine_')) {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(x, y + height / 3, width / 1.5, width / 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            for (let r = 0; r < data.length; r++) {
                for (let c = 0; c < data[0].length; c++) {
                    const char = data[r][c];
                    const color = COLORS[char];
                    if (color) {
                        ctx.fillStyle = color;
                        ctx.fillRect(startX + c * scale, startY + r * scale, scale, scale);
                    }
                }
            }
        }

        function addLogEntry(speakerType, message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const hours = Math.floor(gameState.time / 60);
            const mins = Math.min(59, Math.floor(gameState.time % 60)); // FIXED: Prevent 60 minutes
            const timeStr = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;

            let speakerName = "Unknown";
            let speakerClass = "";

            if (speakerType === 'resident') { speakerName = "Res"; speakerClass = "sp-resident"; }
            else if (speakerType === 'mom') { speakerName = "Mom"; speakerClass = "sp-mom"; }
            else if (speakerType === 'dad') { speakerName = "Dad"; speakerClass = "sp-dad"; }
            else if (speakerType === 'surgeon') { speakerName = "Surg"; speakerClass = "sp-surgeon"; }
            else if (speakerType === 'nurse') { speakerName = "You"; speakerClass = "sp-nurse"; }
            else if (speakerType === 'admin') { speakerName = "Admin"; speakerClass = "sp-admin"; }
            else if (speakerType === 'baby') { speakerName = "Baby"; speakerClass = "text-white"; }
            // New Types
            else if (speakerType === 'medicalfamily') { speakerName = "Fam"; speakerClass = "sp-mom"; } // Reuse mom color
            else if (speakerType === 'sickvisitor') { speakerName = "Vis"; speakerClass = "text-green-400"; }
            else if (speakerType === 'floorcleaner') { speakerName = "Clean"; speakerClass = "text-gray-500"; }

            entry.innerHTML = `
            <span class="log-time">${timeStr}</span>
            <span class="log-speaker ${speakerClass}">${speakerName}:</span>
            <span class="log-msg">${message}</span>
        `;

            logPanel.prepend(entry);
            if (logPanel.children.length > 50) logPanel.lastElementChild.remove();
        }

        function togglePause() {
            if (gameState.mode !== 'GAME') return;

            gameState.paused = !gameState.paused;

            const sassyPhrases = [
                "Cool it!",
                "Hush!",
                "I can't even.",
                "Unbelievable.",
                "Silence.",
                "Not today.",
                "Excuse you?",
                "I'm on break."
            ];

            if (gameState.paused) {
                gameState.pausePhrase = sassyPhrases[Math.floor(Math.random() * sassyPhrases.length)];
                pauseBtn.innerText = "‚ñ∂ RESUME";
                pauseBtn.style.backgroundColor = "#4299e1";
            } else {
                pauseBtn.innerText = "‚è∏ PAUSE";
                pauseBtn.style.backgroundColor = "#e53e3e";
                gameState.lastTime = performance.now();
            }
        }

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
        }

        class Entity {
            constructor(x, y, type) {
                this.pos = new Vector(x, y);
                this.target = null;
                this.type = type;
                this.size = SPRITES[type] ? SPRITES[type][0].length * PIXEL_SCALE / 2 : 60;
                this.speed = 2;
                this.state = 'idle';
                this.timer = 0;
                this.markedForDeletion = false;
                this.bubble = null;
            }

            update(dt) {
                if (this.state === 'moving' && this.target) {
                    const dx = this.target.x - this.pos.x;
                    const dy = this.target.y - this.pos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.speed) {
                        this.pos.x = this.target.x;
                        this.pos.y = this.target.y;
                        this.state = 'idle';
                        this.onArrive();
                    } else {
                        this.pos.x += (dx / dist) * this.speed;
                        this.pos.y += (dy / dist) * this.speed;
                    }
                }
                if (this.bubble) {
                    this.bubble.life -= dt;
                    if (this.bubble.life <= 0) this.bubble = null;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                this.drawBody(ctx);
                if (this.bubble) {
                    ctx.font = `${20 * (PIXEL_SCALE / 4)}px "Vt323"`;
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(-40, -100, 80, 60, 5);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'center';
                    ctx.fillText("...", 0, -60);
                }
                ctx.restore();
            }

            drawBody(ctx) { }
            onArrive() { }

            say(text, logSpeakerType = null) {
                this.bubble = { text: "...", life: 2000 };
                addLogEntry(logSpeakerType || this.type, text);
            }
        }

        class Nurse extends Entity {
            constructor(x, y) {
                super(x, y, 'nurse');
                this.speed = 4 * (PIXEL_SCALE / 4);
                this.baseSpeed = 4 * (PIXEL_SCALE / 4);
                this.size = SPRITES.nurse[0].length * PIXEL_SCALE / 2;
                this.shieldTimer = 0;
                this.freezeTimer = 0;
            }
            update(dt) {
                // Freeze Logic
                if (this.freezeTimer > 0) {
                    this.freezeTimer -= dt;
                    return; // Don't move or act
                }

                // Keyboard Movement
                if (keys.w || keys.a || keys.s || keys.d || keys.up || keys.down || keys.left || keys.right) {
                    // Cancel sitting state
                    if (this.state === 'sitting') {
                        this.state = 'idle';
                    }

                    // Cancel click-to-move target
                    this.target = null;
                    this.state = 'idle';

                    // Calculate movement vector
                    let dx = 0, dy = 0;
                    if (keys.w || keys.up) dy -= 1;
                    if (keys.s || keys.down) dy += 1;
                    if (keys.a || keys.left) dx -= 1;
                    if (keys.d || keys.right) dx += 1;

                    // Normalize diagonal movement
                    if (dx !== 0 && dy !== 0) {
                        dx *= 0.707;
                        dy *= 0.707;
                    }

                    // Apply movement
                    if (dx !== 0 || dy !== 0) {
                        this.pos.x += dx * this.speed;
                        this.pos.y += dy * this.speed;

                        // Clamp to canvas bounds
                        this.pos.x = Math.max(30, Math.min(canvas.width - 30, this.pos.x));
                        this.pos.y = Math.max(30, Math.min(canvas.height - 30, this.pos.y));

                        this.state = 'walking'; // For animation system (if we had one, but keeps state consistent)
                    }
                }

                // Shield Logic
                if (this.shieldTimer > 0) {
                    this.shieldTimer -= dt;
                }

                if (this.state === 'sitting') {
                    gameState.sanity += 0.15;
                    if (gameState.sanity > 100) gameState.sanity = 100;
                    if (Math.random() < 0.005 && !this.bubble) {
                        this.say("My feet hurt...", 'nurse');
                    }
                    return;
                }
                if (gameState.coffeeBoost > 0) {
                    let speedBoost = 1.8;
                    if (gameState.nightShift) speedBoost = 2.5; // Night shift: stronger coffee
                    this.speed = this.baseSpeed * speedBoost;
                    gameState.coffeeBoost -= dt;
                } else {
                    this.speed = this.baseSpeed;
                }
                super.update(dt);
            }
            draw(ctx) {
                let sprite = 'nurse';
                if (this.state === 'sitting') sprite = 'nurse_sit';

                // Draw Shield Effect
                if (this.shieldTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 100) * 0.1;
                    ctx.fillStyle = '#68d391';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Draw Freeze Effect
                if (this.freezeTimer > 0) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(66, 153, 225, 0.5)';
                    ctx.fillRect(this.pos.x - 20, this.pos.y - 40, 40, 80);
                    ctx.restore();
                }

                drawSprite(ctx, sprite, this.pos.x, this.pos.y);

                if (gameState.coffeeBoost > 0 && this.state !== 'sitting') {
                    ctx.fillStyle = 'orange';
                    ctx.font = `${20 * (PIXEL_SCALE / 4)}px Arial`;
                    ctx.fillText('‚ö°', this.pos.x + 10 * (PIXEL_SCALE / 4), this.pos.y - 20 * (PIXEL_SCALE / 4));
                }
                if (this.bubble) {
                    ctx.font = `${20 * (PIXEL_SCALE / 4)}px "Vt323"`;
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(this.pos.x - 40, this.pos.y - 100, 80, 60, 5);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'center';
                    ctx.fillText("...", this.pos.x, this.pos.y - 60);
                }
            }
        }

        class Isolette extends Entity {
            constructor(x, y, id) {
                super(x, y, 'isolette');
                this.id = id;
                this.needs = [];
                this.needTimer = Math.random() * 5000 + 5000;
                this.size = 15 * (PIXEL_SCALE / 4);
            }
            update(dt) {
                this.needTimer -= dt;
                if (this.needTimer <= 0 && this.needs.length < 3) {
                    const possibleNeeds = ['feed', 'diaper', 'assessment', 'hold', 'procedure', 'photo'];
                    // Weighted random for needs
                    let newNeed = 'feed';
                    const roll = Math.random();
                    if (roll < 0.3) newNeed = 'feed';
                    else if (roll < 0.5) newNeed = 'diaper';
                    else if (roll < 0.65) newNeed = 'assessment';
                    else if (roll < 0.8) newNeed = 'hold';
                    else if (roll < 0.9) newNeed = 'procedure';
                    else newNeed = 'photo';

                    if (!this.needs.includes(newNeed)) {
                        this.needs.push(newNeed);
                        playSoundVisual(this.pos.x, this.pos.y, "BEEP!");
                        playBeep(600, 150);
                    }
                    this.needTimer = Math.random() * 10000 + 10000;
                }
                if (this.needs.length > 0) {
                    let drain = 0.01;
                    if (gameState.shortStaffed) drain *= 1.5; // Short-staffed increases drain
                    if (gameState.nightShift) drain *= 1.2; // Night shift increases drain
                    gameState.sanity -= drain;
                }
            }
            drawBody(ctx) {
                const scaleFactor = PIXEL_SCALE / 6;
                ctx.fillStyle = '#a0aec0'; ctx.fillRect(-15 * scaleFactor, -8 * scaleFactor, 30 * scaleFactor, 25 * scaleFactor);
                ctx.fillStyle = '#718096'; ctx.fillRect(-15 * scaleFactor, 17 * scaleFactor, 30 * scaleFactor, 4 * scaleFactor);
                ctx.fillStyle = '#edf2f7'; ctx.beginPath(); ctx.arc(0, -8 * scaleFactor, 18 * scaleFactor, Math.PI, 0); ctx.fill();

                const babyData = SPRITES.baby;
                const babyPixelScale = PIXEL_SCALE / 3;
                const startX = - (babyData[0].length * babyPixelScale) / 2;
                const startY = -12 * scaleFactor;
                for (let r = 0; r < babyData.length; r++) {
                    for (let c = 0; c < babyData[0].length; c++) {
                        if (COLORS[babyData[r][c]]) {
                            ctx.fillStyle = COLORS[babyData[r][c]];
                            ctx.fillRect(startX + c * babyPixelScale, startY + r * babyPixelScale, babyPixelScale, babyPixelScale);
                        }
                    }
                }
                ctx.fillStyle = 'rgba(190, 240, 255, 0.4)'; ctx.beginPath(); ctx.arc(0, -8 * scaleFactor, 18 * scaleFactor, Math.PI, 0); ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1 * scaleFactor; ctx.stroke();
                ctx.font = `${20 * scaleFactor}px Arial`;
                if (this.needs.includes('feed')) ctx.fillText('üçº', -10 * scaleFactor, -25 * scaleFactor);
                if (this.needs.includes('diaper')) ctx.fillText('üí©', 10 * scaleFactor, -25 * scaleFactor);
                if (this.needs.includes('assessment')) ctx.fillText('üìã', -20 * scaleFactor, -10 * scaleFactor);
                if (this.needs.includes('hold')) ctx.fillText('ü§±', 20 * scaleFactor, -10 * scaleFactor);
                if (this.needs.includes('procedure')) ctx.fillText('üíâ', -10 * scaleFactor, 10 * scaleFactor);
                if (this.needs.includes('photo')) ctx.fillText('üì∏', 10 * scaleFactor, 10 * scaleFactor);
            }
        }

        class Machine extends Entity {
            constructor(x, y, type) { super(x, y, type); this.size = 20; }
            drawBody(ctx) { drawSprite(ctx, this.type, 0, 0, PIXEL_SCALE / 2); }
            update(dt) { }
        }

        class Enemy extends Entity {
            constructor(x, y, type, targetIsolette) {
                super(x, y, type);
                this.targetIsolette = targetIsolette;

                // Default target (isolette)
                if (targetIsolette) {
                    this.target = new Vector(targetIsolette.pos.x, targetIsolette.pos.y + 40 * (PIXEL_SCALE / 4));
                } else {
                    // For floorcleaner who doesn't target isolettes
                    this.target = new Vector(canvas.width + 100, y);
                }

                this.state = 'moving';
                this.speed = 1.5 * (PIXEL_SCALE / 4);

                // Type specific stats
                if (type === 'surgeon') this.speed = 2.5 * (PIXEL_SCALE / 4);
                if (type === 'floorcleaner') {
                    this.speed = 1.0 * (PIXEL_SCALE / 4);
                    this.target = new Vector(canvas.width + 100, y); // Go straight across
                }

                this.annoyanceLevel = 0;
                this.maxAnnoyance = 100;
                if (type === 'medicalfamily') this.maxAnnoyance = 150;

                this.active = true;
                this.size = SPRITES[type] ? SPRITES[type][0].length * PIXEL_SCALE / 2 : 60;

                // Floor cleaner noise field
                this.noiseTimer = 0;
            }

            onArrive() {
                if (this.type === 'floorcleaner') {
                    this.markedForDeletion = true; // Despawn when reaching other side
                    return;
                }

                this.state = 'annoying';
                let quotes = [];
                if (this.type === 'resident') quotes = ["Is this kid NPO?", "Vein finder?", "Ordering full workup."];
                if (this.type === 'mom') quotes = ["Why is he crying?", "Is that machine beeping?", "I read online..."];
                if (this.type === 'dad') quotes = ["I'm scared.", "Where's the coffee?", "Can I go home?"];
                if (this.type === 'surgeon') quotes = ["NPO. Now.", "Call the Fellow.", "My way or highway."];

                // New Enemy Quotes
                if (this.type === 'medicalfamily') quotes = ["I'm a vet, so...", "WebMD says...", "I took anatomy once."];
                if (this.type === 'sickvisitor') quotes = ["*cough*", "It's just allergies.", "I'm not contagious."];

                this.say(quotes[Math.floor(Math.random() * quotes.length)]);
            }

            leave() {
                this.active = false;
                this.target = new Vector(canvas.width + 50, canvas.height / 2);
                this.state = 'moving';
                this.bubble = null;
                setTimeout(() => { this.markedForDeletion = true; }, 5000);
            }

            update(dt) {
                super.update(dt);

                // Floor Cleaner Logic
                if (this.type === 'floorcleaner') {
                    // Noise field logic
                    if (nurse.pos.dist(this.pos) < 150) {
                        if (nurse.shieldTimer <= 0) { // Check shield
                            gameState.sanity -= 0.2; // High drain
                        }
                        this.noiseTimer += dt;
                        if (this.noiseTimer > 500) {
                            playSoundVisual(this.pos.x, this.pos.y - 40, "RUMBLE");
                            this.noiseTimer = 0;
                        }
                    }
                    return; // Doesn't do normal annoyance
                }

                // Photographer Logic
                if (this.type === 'photographer') {
                    if (Math.random() < 0.01) {
                        // Flash effect
                        playSoundVisual(this.pos.x, this.pos.y, "FLASH!");
                        playBeep(1000, 50);
                        // Wake babies
                        isolettes.forEach(i => {
                            if (Math.random() < 0.3 && i.needs.length === 0) {
                                i.needs.push('calm');
                                addLogEntry('nurse', "Flash woke the baby!");
                            }
                        });
                    }
                }

                // Attending Logic
                if (this.type === 'attending') {
                    if (nurse.pos.dist(this.pos) > 150) {
                        // Must stay close
                        if (nurse.shieldTimer <= 0) {
                            gameState.sanity -= 0.1; // Fast drain if ignored
                        }
                        if (Math.random() < 0.01) addLogEntry('attending', "Where are you going?");
                    } else {
                        // Being near restores a bit or just stops drain
                        gameState.sanity += 0.01;
                    }
                }

                // Sick Visitor Logic
                if (this.type === 'sickvisitor' && this.state === 'annoying') {
                    if (Math.random() < 0.02) {
                        // Sneeze particles
                        for (let i = 0; i < 5; i++) {
                            particles.push({
                                x: this.pos.x,
                                y: this.pos.y - 20,
                                text: '*',
                                color: '#48bb78',
                                life: 40 + Math.random() * 20
                            });
                        }
                        playSoundVisual(this.pos.x, this.pos.y - 40, "*ACHOO*");
                    }
                }

                if (this.state === 'annoying' && this.active) {
                    this.annoyanceLevel += 0.5;
                    let drain = 0.05;
                    if (this.type === 'surgeon') drain = 0.15;
                    if (this.type === 'medicalfamily') drain = 0.08;
                    if (this.type === 'sickvisitor') drain = 0.07;

                    if (nurse.shieldTimer <= 0) { // Check shield
                        gameState.sanity -= drain;
                    }

                    if (this.annoyanceLevel >= this.maxAnnoyance) {
                        if (this.type === 'resident' || this.type === 'surgeon') {
                            playSoundVisual(this.pos.x, this.pos.y, "BABY WOKEN!");
                            this.targetIsolette.needs.push('calm');
                            addLogEntry(this.type, "Whoops, woke the baby.");
                            playBeep(300, 200);
                        } else {
                            addLogEntry(this.type, "I'm going to find the charge nurse.");
                        }
                        this.leave();
                    }
                }
            }

            draw(ctx) {
                drawSprite(ctx, this.type, this.pos.x, this.pos.y);

                // Draw noise field for cleaner
                if (this.type === 'floorcleaner') {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 150, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                if (this.state === 'annoying') {
                    const bw = 30 * (PIXEL_SCALE / 4); const bh = 5 * (PIXEL_SCALE / 4); const by = -50 * (PIXEL_SCALE / 4);
                    ctx.fillStyle = '#feb2b2'; ctx.fillRect(this.pos.x - bw / 2, this.pos.y + by, bw, bh);
                    ctx.fillStyle = '#f56565'; ctx.fillRect(this.pos.x - bw / 2, this.pos.y + by, bw * (this.annoyanceLevel / this.maxAnnoyance), bh);
                }
                if (this.bubble) {
                    ctx.font = `${20 * (PIXEL_SCALE / 4)}px "Vt323"`; ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.roundRect(this.pos.x - 40, this.pos.y - 100, 80, 60, 5); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = 'black'; ctx.textAlign = 'center'; ctx.fillText("...", this.pos.x, this.pos.y - 60);
                }
            }
        }

        class Item extends Entity {
            constructor(x, y, type) {
                super(x, y, type); this.timer = 9000;
                if (type === 'coffee') this.size = SPRITES.coffee[0].length * PIXEL_SCALE / 2;
                else this.size = 30 * (PIXEL_SCALE / 4);
            }
            update(dt) { this.timer -= dt; if (this.timer <= 0) this.markedForDeletion = true; }
            draw(ctx) {
                if (this.type === 'coffee') drawSprite(ctx, 'coffee', this.pos.x, this.pos.y);
                else {
                    ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.font = `${30 * (PIXEL_SCALE / 4)}px Arial`;
                    if (this.type === 'pizza') ctx.fillText('üçï', 0, 0);
                    else if (this.type === 'bathroom') ctx.fillText('üßª', 0, 0);
                    else if (this.type === 'admingift') ctx.fillText('üéÅ', 0, 0);
                    // New Items
                    else if (this.type === 'sanitizer') ctx.fillText('üß¥', 0, 0);
                    else if (this.type === 'workingpump') ctx.fillText('üíâ', 0, 0);
                    else if (this.type === 'coworker') ctx.fillText('üë©‚Äç‚öïÔ∏è', 0, 0);
                    else if (this.type === 'trainingemail') ctx.fillText('üìß', 0, 0);
                    else if (this.type === 'missingsupply') ctx.fillText('‚ùå', 0, 0);
                    else if (this.type === 'brokenequip') ctx.fillText('‚ö†Ô∏è', 0, 0);
                    ctx.restore();
                }
            }
        }

        class ChartingStation extends Entity {
            constructor(x, y) {
                super(x, y, 'charting');
                this.size = 40 * (PIXEL_SCALE / 4);
                this.timer = 30000; // 30 seconds before overdue
                this.maxTimer = 30000;
            }
            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) {
                    gameState.sanity -= 0.05; // Drain when overdue
                    if (Math.random() < 0.01) {
                        addLogEntry('admin', "Documentation overdue!");
                        playBeep(200, 100);
                    }
                }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.pos.x, this.pos.y);
                ctx.fillStyle = this.timer > 0 ? '#4299e1' : '#e53e3e'; // Blue normal, Red overdue
                ctx.fillRect(-20, -20, 40, 40);
                ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('üíª', 0, 0);

                // Timer bar
                if (this.timer > 0) {
                    ctx.fillStyle = '#48bb78';
                    ctx.fillRect(-20, -30, 40 * (this.timer / this.maxTimer), 5);
                }
                ctx.restore();
            }
        }

        class SupplyCart extends Entity {
            constructor(x, y) {
                super(x, y, 'supplycart');
                this.size = 40 * (PIXEL_SCALE / 4);
            }
            update(dt) { }
            draw(ctx) {
                ctx.save(); ctx.translate(this.pos.x, this.pos.y);
                ctx.fillStyle = '#ed8936';
                ctx.fillRect(-20, -20, 40, 40);
                ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('üõí', 0, 0);
                ctx.restore();
            }
        }

        class Pager extends Entity {
            constructor(x, y) {
                super(x, y, 'pager');
                this.size = 30 * (PIXEL_SCALE / 4);
                this.message = null;
                this.timer = 0;
                this.flashState = false;
            }
            update(dt) {
                if (this.message) {
                    this.timer += dt;
                    if (this.timer > 500) {
                        this.flashState = !this.flashState;
                        this.timer = 0;
                        if (this.flashState) playBeep(900, 50);
                    }
                    // Drain sanity if ignored too long
                    gameState.sanity -= 0.005;
                } else {
                    // Random incoming message
                    if (Math.random() < 0.0005) {
                        const msgs = ["Lab: Critical Value", "Family on Line 1", "Pharmacy: Med Clarification", "Charge Nurse: Call me", "RT: Vent Check"];
                        this.message = msgs[Math.floor(Math.random() * msgs.length)];
                        playSoundVisual(this.pos.x, this.pos.y, "BEEP BEEP!");
                    }
                }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.pos.x, this.pos.y);
                ctx.fillStyle = this.message && this.flashState ? '#f56565' : '#2d3748';
                ctx.fillRect(-15, -25, 30, 50);
                ctx.fillStyle = '#a0aec0';
                ctx.fillRect(-10, -20, 20, 15); // Screen

                if (this.message) {
                    ctx.fillStyle = 'red';
                    ctx.font = '20px Arial';
                    ctx.fillText('!', 20, -20);
                }
                ctx.restore();
            }
        }

        class Chair extends Entity {
            constructor(x, y) { super(x, y, 'chair'); }
            draw(ctx) {
                const x = this.pos.x; const y = this.pos.y; const s = PIXEL_SCALE / 4;
                ctx.fillStyle = '#744210';
                ctx.fillRect(x - 10 * s, y, 20 * s, 20 * s); ctx.fillRect(x - 10 * s, y - 20 * s, 5 * s, 20 * s);
                ctx.fillRect(x + 5 * s, y - 20 * s, 5 * s, 20 * s); ctx.fillRect(x - 10 * s, y - 20 * s, 20 * s, 5 * s);
            }
        }

        class Sticker {
            constructor(text, color) {
                this.text = text;
                this.color = color;
                this.x = 0;
                this.y = 0;
                this.onMug = false;
                this.angle = 0;
                this.height = 0;
                this.width = 160;
                this.h = 40;
            }
        }

        function initGame() {
            loadSettings(); // Load settings at start of game
            initAudio(); // FIXED: Initialize audio on first user interaction
            gameState.mode = 'GAME';
            resizeCanvas();
            entities = [];
            particles = [];
            isolettes = [];

            // FIXED: Clear log panel completely
            logPanel.innerHTML = '';
            addLogEntry('admin', "SHIFT START. Mandatory huddle skipped.");

            gameState.time = SHIFT_START;
            gameState.sanity = 100;
            gameState.score = 0;
            gameState.gameOver = false;
            gameState.coffeeBoost = 0;
            gameState.paused = false;
            gameState.stickerDelay = 0;
            gameState.displayedScore = 0;
            gameState.mugFillHeight = 0;
            // Reset Stats
            gameState.stats = {
                babiesFed: 0,
                diapersChanged: 0,
                familiesCalmed: 0,
                alarmsSilenced: 0,
                coffeeConsumed: 0
            };
            // Reset Tutorial State (if not seen)
            if (!settings.tutorialSeen) {
                gameState.tutorial = {
                    moveShown: false,
                    babyShown: false,
                    enemyShown: false,
                    sanityShown: false
                };
                gameState.tutorialMessage = { text: "", timer: 0, alpha: 0 };
            }
            pauseBtn.innerText = "‚è∏ PAUSE";
            pauseBtn.style.backgroundColor = "#e53e3e";
            restartBtn.style.display = 'none';
            gameUiTop.style.display = 'flex';
            logPanel.style.display = 'flex';

            // Randomly decide if it's a night shift
            gameState.nightShift = Math.random() < 0.3; // 30% chance of night shift
            if (gameState.nightShift) {
                addLogEntry('admin', "It's a night shift. Good luck with the dark.");
            }

            const cols = 3;
            const rows = 2;
            const startX = canvas.width * 0.15;
            const startY = canvas.height * 0.3;
            const gapX = canvas.width * 0.25;
            const gapY = canvas.height * 0.4;

            // Add Charting Station, Supply Cart, and Pager
            entities.push(new ChartingStation(canvas.width - 60, 60));
            entities.push(new SupplyCart(60, canvas.height - 60));
            entities.push(new Pager(canvas.width - 120, 60)); // Add Pager

            // Initial Spawn
            spawnEnemy();

            let idCount = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const isoX = startX + c * gapX;
                    const isoY = startY + r * gapY;
                    isolettes.push(new Isolette(isoX, isoY, idCount++));
                    const machineType = ['machine_monitor', 'machine_iv', 'machine_vent'][Math.floor(Math.random() * 3)];
                    entities.push(new Machine(isoX + 50, isoY - 20, machineType));
                }
            }
            entities.push(...isolettes);
            chair = new Chair(canvas.width * 0.6, canvas.height * 0.9);
            entities.push(chair);
            nurse = new Nurse(canvas.width / 2, canvas.height / 2);
            entities.push(nurse);
        }

        function spawnEnemy() {
            let spawnRate = 0.005;
            if (gameState.shortStaffed) spawnRate *= 1.3; // Increase for short-staffed
            if (Math.random() > spawnRate) return;
            const typeRoll = Math.random();
            let type = 'resident';

            // New Spawn Logic
            // Expanded Spawn Logic
            if (typeRoll < 0.05) type = 'floorcleaner';
            else if (typeRoll < 0.10) type = 'photographer'; // New
            else if (typeRoll < 0.15) type = 'attending'; // New
            else if (typeRoll < 0.35) type = 'resident';
            else if (typeRoll < 0.55) type = 'surgeon';
            else if (typeRoll < 0.75) type = 'medicalfamily';
            else if (typeRoll < 0.85) type = 'sickvisitor';
            else if (Math.random() > 0.5) type = 'mom';
            else type = 'dad';

            if (type === 'floorcleaner') {
                // Spawns at left, goes right
                entities.push(new Enemy(-50, canvas.height / 2 + 100, type, null));
            } else {
                const targetIsolette = isolettes[Math.floor(Math.random() * isolettes.length)];
                entities.push(new Enemy(Math.random() > 0.5 ? -50 : canvas.width + 50, Math.random() * canvas.height, type, targetIsolette));
            }
        }

        function spawnItem() {
            if (Math.random() > 0.004) return;
            const roll = Math.random();
            let type = 'coffee';

            // Expanded Item Pool
            if (roll < 0.4) type = 'coffee';
            else if (roll < 0.5) type = 'pizza';
            else if (roll < 0.6) type = 'bathroom';
            else if (roll < 0.7) type = 'admingift';
            // New Items
            else if (roll < 0.75) type = 'sanitizer';
            else if (roll < 0.80) type = 'workingpump';
            else if (roll < 0.85) type = 'coworker';
            else if (roll < 0.90) type = 'trainingemail';
            else if (roll < 0.95) type = 'missingsupply';
            else type = 'brokenequip';

            entities.push(new Item(Math.random() * (canvas.width - 350) + 50, Math.random() * (canvas.height - 100) + 50, type));
        }

        function update(dt) {
            // Night Shift Flicker Logic
            if (gameState.nightShift) {
                gameState.flickerTimer -= dt;
                if (gameState.flickerTimer <= 0) {
                    // Random chance of flicker
                    if (Math.random() < 0.1) {
                        gameState.flickerIntensity = Math.random() * 3;
                    } else {
                        gameState.flickerIntensity = 0;
                    }
                    gameState.flickerTimer = 100 + Math.random() * 200;
                }
            } else {
                gameState.flickerIntensity = 0;
            }

            if (gameState.mode === 'REPORTOFF') {
                gameState.cutsceneTimer += dt;

                // Incoming nurse walks in
                if (gameState.cutsceneTimer < 2000) {
                    gameState.incomingNursePos.x -= (dt / 1000) * 100; // Move left
                    if (gameState.incomingNursePos.x < canvas.width - 100) gameState.incomingNursePos.x = canvas.width - 100;
                }

                // End cutscene after 6 seconds
                if (gameState.cutsceneTimer > 6000) {
                    gameState.mode = 'SUMMARY';
                }
                return;
            }

            if (gameState.mode === 'MUG') {
                if (gameState.inventoryStickers.length > 0) {
                    gameState.stickerDelay--;
                    if (gameState.stickerDelay <= 0) {
                        const s = gameState.inventoryStickers.shift();

                        // 2D positioning: Bottom to top, constrained to cup
                        const mugH = 500; // Taller cup
                        const mugW = 240; // Top width
                        const mugBaseW = 180; // Bottom width
                        const mugBottomY = canvas.height / 2 + mugH / 2;

                        // Calculate available width at current height
                        const currentY = mugBottomY - gameState.mugFillHeight - 30;
                        const progress = gameState.mugFillHeight / mugH;
                        const currentWidth = mugBaseW + (mugW - mugBaseW) * progress;

                        // Constrain X to be within the cup at this height
                        // Sticker width is approx 160, so we need to be careful
                        const maxOffset = (currentWidth - 160) / 2;
                        // Clamp offset to ensure it stays inside
                        const randomOffset = (Math.random() * maxOffset * 2) - maxOffset;

                        s.x = (canvas.width / 2) + randomOffset;
                        s.y = currentY;
                        s.angle = (Math.random() * 0.1) - 0.05; // Very slight tilt for "lined up" look

                        gameState.mugFillHeight += 45; // Tighter packing
                        gameState.displayedScore += 200; // Animate score

                        gameState.mugStickers.push(s);
                        playSoundVisual(s.x, s.y, "STICKER!");
                        playBeep(800 + Math.random() * 400, 100);
                        gameState.stickerDelay = 20; // Faster placement
                    }
                } else if (gameState.stickerDelay > 0) {
                    gameState.stickerDelay--;
                } else {
                    restartBtn.style.display = 'block';
                }
                return;
            }

            if (!gameState.running || gameState.gameOver) return;

            gameState.time += (dt / MS_PER_GAME_MINUTE);
            if (gameState.time >= SHIFT_END) endGame(true);
            if (gameState.time >= SHIFT_END) endGame(true);
            if (gameState.sanity <= 0) { gameState.sanity = 0; endGame(false); }

            // Simultaneous Alarm Logic
            const alarmedBabies = isolettes.filter(i => i.needs.length > 0).length;
            if (alarmedBabies > 3) {
                gameState.sanity -= 0.05; // Extra drain
                if (Math.random() < 0.02) {
                    playSoundVisual(canvas.width / 2, canvas.height / 2, "ALARM SYMPHONY!");
                    playBeep(800, 300);
                }
            }

            // Random Positive Events (Sprint 5)
            gameState.eventTimer += dt;
            if (gameState.eventTimer > 30000) { // Every 30 seconds
                gameState.eventTimer = 0;
                if (Math.random() < 0.15) { // 15% chance
                    const events = [
                        { msg: "Parent brought cookies!", sanity: 20 },
                        { msg: "All babies sleeping!", sanity: 50 },
                        { msg: "Attending canceled rounds!", sanity: 30 },
                        { msg: "Break nurse showed up!", sanity: 25 }
                    ];
                    const event = events[Math.floor(Math.random() * events.length)];
                    gameState.sanity = Math.min(100, gameState.sanity + event.sanity);
                    addLogEntry('admin', event.msg);
                    playSoundVisual(canvas.width / 2, canvas.height / 2, "GOOD NEWS!");
                    playBeep(1000, 200);
                }
            }

            spawnEnemy();
            spawnItem();

            entities.forEach(e => e.update(dt));
            entities = entities.filter(e => !e.markedForDeletion);

            entities.filter(e => ['coffee', 'pizza', 'bathroom', 'admingift', 'sanitizer', 'workingpump', 'coworker', 'trainingemail', 'missingsupply', 'brokenequip'].includes(e.type)).forEach(item => {
                if (nurse.pos.dist(item.pos) < 40 + item.size / 2 && !item.markedForDeletion) {
                    item.markedForDeletion = true;
                    if (item.type === 'coffee') {
                        gameState.coffeeBoost = 5000;
                        playSoundVisual(item.pos.x, item.pos.y, "CAFFEINE!");
                        gameState.sanity = Math.min(100, gameState.sanity + 5);
                        gameState.stats.coffeeConsumed++; // Track stat
                        addLogEntry('nurse', "Chugged coffee.");
                        playBeep(800, 100);
                    }
                    else if (item.type === 'pizza') {
                        playSoundVisual(item.pos.x, item.pos.y, "Pizza!");
                        gameState.sanity = Math.min(100, gameState.sanity + 20);
                        addLogEntry('nurse', "Cold pizza. Delicious.");
                        playBeep(400, 150);
                    }
                    else if (item.type === 'bathroom') {
                        playSoundVisual(item.pos.x, item.pos.y, "BREAK!");
                        gameState.sanity = Math.min(100, gameState.sanity + 40);
                        addLogEntry('nurse', "Silence. Bliss.");
                        playBeep(500, 200);
                    }
                    else if (item.type === 'admingift') {
                        playSoundVisual(item.pos.x, item.pos.y, "TRAP!");
                        gameState.sanity -= 10;
                        addLogEntry('admin', "Heroes Work Here (rock).");
                        addLogEntry('nurse', "Seriously?!");
                        playBeep(200, 300);
                    }
                    // New Item Effects
                    else if (item.type === 'sanitizer') {
                        playSoundVisual(item.pos.x, item.pos.y, "SHIELD!");
                        gameState.sanity = Math.min(100, gameState.sanity + 15);
                        addLogEntry('nurse', "Clean hands, clear mind.");
                        nurse.shieldTimer = 3000; // 3 seconds
                        playBeep(600, 150);
                    }
                    else if (item.type === 'workingpump') {
                        playSoundVisual(item.pos.x, item.pos.y, "FIXED!");
                        gameState.sanity = Math.min(100, gameState.sanity + 10);
                        // Auto-fix one isolette
                        const needyIso = isolettes.find(i => i.needs.length > 0);
                        if (needyIso) {
                            needyIso.needs.shift();
                            addLogEntry('nurse', "Pump fixed a problem!");
                        } else {
                            addLogEntry('nurse', "Equipment actually works!");
                        }
                        playBeep(700, 150);
                    }
                    else if (item.type === 'coworker') {
                        playSoundVisual(item.pos.x, item.pos.y, "HELP!");
                        gameState.sanity = Math.min(100, gameState.sanity + 25);
                        // Dismiss one enemy
                        const annoyingEnemy = entities.find(e => e instanceof Enemy && e.active && e.state === 'annoying');
                        if (annoyingEnemy) {
                            annoyingEnemy.leave();
                            addLogEntry('nurse', "Coworker: I got this one.");
                        } else {
                            addLogEntry('nurse', "Coworker: Just checking in.");
                        }
                        playBeep(800, 150);
                    }
                    else if (item.type === 'trainingemail') {
                        playSoundVisual(item.pos.x, item.pos.y, "DUE NOW!");
                        gameState.sanity -= 20;
                        addLogEntry('admin', "MANDATORY MODULE DUE.");
                        nurse.freezeTimer = 1000; // Freeze for 1s
                        playBeep(150, 400);
                    }
                    else if (item.type === 'missingsupply') {
                        playSoundVisual(item.pos.x, item.pos.y, "EMPTY!");
                        gameState.sanity -= 15;
                        addLogEntry('nurse', "Where are the wipes?!");
                        playBeep(200, 300);
                    }
                    else if (item.type === 'brokenequip') {
                        playSoundVisual(item.pos.x, item.pos.y, "ALARM!");
                        gameState.sanity -= 10;
                        addLogEntry('nurse', "Why is this broken?!");
                        playBeep(800, 500); // Long beep
                    }
                }
            });

            // Charting Station Interaction
            const chartingStation = entities.find(e => e instanceof ChartingStation);
            if (chartingStation && nurse.pos.dist(chartingStation.pos) < 60) {
                if (chartingStation.timer < chartingStation.maxTimer) {
                    chartingStation.timer = Math.min(chartingStation.maxTimer, chartingStation.timer + dt * 2); // Recharge
                    if (chartingStation.timer >= chartingStation.maxTimer) {
                        addLogEntry('nurse', "Documentation complete.");
                        playSoundVisual(chartingStation.pos.x, chartingStation.pos.y, "SAVED!");
                    }
                }
            }

            // Supply Cart Interaction
            const supplyCart = entities.find(e => e instanceof SupplyCart);
            if (supplyCart && nurse.pos.dist(supplyCart.pos) < 60) {
                // Just a visual interaction for now, maybe add supply count later
                if (Math.random() < 0.01) {
                    addLogEntry('nurse', "Restocked supplies.");
                }
            }

            // Pager Interaction
            const pager = entities.find(e => e instanceof Pager);
            if (pager && pager.message && nurse.pos.dist(pager.pos) < 60) {
                // Click to clear (simulated by proximity for now, or add click handler later)
                // For now, let's just auto-clear if close enough for 1 second? 
                // No, let's make it instant for better flow
                addLogEntry('nurse', "Message acknowledged.");
                pager.message = null;
                playSoundVisual(pager.pos.x, pager.pos.y, "CLEARED");
            }

            if (nurse.state === 'idle') {
                isolettes.forEach(iso => {
                    if (nurse.pos.dist(iso.pos) < 50 + iso.size / 2 && iso.needs.length > 0) {
                        const need = iso.needs.shift();
                        if (need === 'feed') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "+15g");
                            gameState.score += 100;
                            gameState.stats.babiesFed++; // Track stat
                            addLogEntry('nurse', nurseResponses.feedBaby[Math.floor(Math.random() * nurseResponses.feedBaby.length)]);
                            playBeep(700, 100);
                        }
                        else if (need === 'diaper') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Clean!");
                            gameState.score += 50;
                            gameState.stats.diapersChanged++; // Track stat
                            addLogEntry('nurse', nurseResponses.changeDiaper[Math.floor(Math.random() * nurseResponses.changeDiaper.length)]);
                            playBeep(650, 100);
                        }
                        else if (need === 'calm') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Shhh...");
                            gameState.score += 20;
                            gameState.stats.alarmsSilenced++; // Track stat
                            addLogEntry('nurse', nurseResponses.calmBaby[Math.floor(Math.random() * nurseResponses.calmBaby.length)]);
                            playBeep(450, 150);
                        }
                        // New Needs
                        else if (need === 'assessment') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Assessed");
                            gameState.score += 150;
                            addLogEntry('nurse', "Assessment complete. Stable.");
                            playBeep(500, 200);
                        }
                        else if (need === 'hold') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Holding...");
                            gameState.score += 75;
                            addLogEntry('nurse', "Parent holding baby.");
                            // Simulate time taken
                            nurse.freezeTimer = 1000;
                            playBeep(400, 300);
                        }
                        else if (need === 'procedure') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Procedure");
                            gameState.sanity -= 5; // Stressful
                            gameState.score += 100;
                            addLogEntry('nurse', "Procedure done. Parents watched.");
                            playBeep(600, 200);
                        }
                        else if (need === 'photo') {
                            playSoundVisual(iso.pos.x, iso.pos.y, "Cheese!");
                            gameState.score += 50;
                            addLogEntry('nurse', "Cute photo taken.");
                            playBeep(800, 50);
                        }
                    }
                });
            }

            if (nurse.state === 'idle' && nurse.pos.dist(chair.pos) < 40 + chair.size) {
                nurse.state = 'sitting'; nurse.pos.x = chair.pos.x; nurse.pos.y = chair.pos.y; addLogEntry('nurse', "Sitting down...");
            }

            if (nurse.state !== 'sitting') {
                entities.filter(e => ['resident', 'mom', 'dad', 'surgeon', 'medicalfamily', 'sickvisitor'].includes(e.type) && e.active && e.state === 'annoying').forEach(enemy => {
                    if (nurse.pos.dist(enemy.pos) < 60 + enemy.size / 2) {
                        // Sick visitor check
                        if (enemy.type === 'sickvisitor' && gameState.sanity < 100) {
                            nurse.say("I can't deal with this right now!");
                            return;
                        }

                        nurse.say(nurseResponses.dismissEnemy[Math.floor(Math.random() * nurseResponses.dismissEnemy.length)]);
                        enemy.leave();

                        let score = 200;
                        if (enemy.type === 'medicalfamily') score = 250;
                        gameState.score += score;
                        gameState.stats.familiesCalmed++; // Track stat

                        playSoundVisual(enemy.pos.x, enemy.pos.y, "Handled.");
                        playBeep(900, 150);
                    }
                });
            }

            // FIXED: Use filter instead of splice in forEach
            particles = particles.filter(p => {
                p.y -= 1;
                p.life--;
                return p.life > 0;
            });

            // Tutorial Logic
            if (!settings.tutorialSeen) {
                // Movement Hint
                if (!gameState.tutorial.moveShown && gameState.time < SHIFT_START + 5) {
                    showTutorial("Use WASD or Arrows to Move. Click to Interact.");
                    gameState.tutorial.moveShown = true;
                }

                // Baby Hint
                if (!gameState.tutorial.babyShown) {
                    const needyIso = isolettes.find(i => i.needs.length > 0);
                    if (needyIso) {
                        showTutorial("Baby needs help! Click the isolette!");
                        gameState.tutorial.babyShown = true;
                    }
                }

                // Enemy Hint
                if (!gameState.tutorial.enemyShown) {
                    const enemy = entities.find(e => e instanceof Enemy && e.active && e.state === 'annoying');
                    if (enemy) {
                        showTutorial("They are annoying! Click them to dismiss!");
                        gameState.tutorial.enemyShown = true;
                    }
                }

                // Sanity Hint
                if (!gameState.tutorial.sanityShown && gameState.sanity < 70) {
                    showTutorial("Sanity dropping! Find coffee or take a break!");
                    gameState.tutorial.sanityShown = true;
                }

                // Update Message Timer
                if (gameState.tutorialMessage.timer > 0) {
                    gameState.tutorialMessage.timer -= dt;
                    if (gameState.tutorialMessage.timer < 1000) {
                        gameState.tutorialMessage.alpha = gameState.tutorialMessage.timer / 1000;
                    } else {
                        gameState.tutorialMessage.alpha = 1;
                    }
                } else {
                    gameState.tutorialMessage.alpha = 0;
                }
            }

            updateHUD(); // FIXED: Moved from draw() to update()
        }

        function drawNightShiftOverlay() {
            if (!gameState.nightShift) return;

            // Darken the entire screen
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 20, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Vignette effect
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.8
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 30, 0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Flicker effect (random light fluctuation)
            if (gameState.flickerIntensity > 0) {
                ctx.fillStyle = `rgba(255, 255, 200, ${gameState.flickerIntensity * 0.1})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            ctx.restore();
        }

        function draw() {
            if (gameState.mode === 'REPORTOFF') {
                drawReportOff();
                return;
            }

            if (gameState.mode === 'SUMMARY') {
                drawSummaryScreen();
                return;
            }
            if (gameState.mode === 'MUG') {
                drawMugScreen();
                return;
            }
            ctx.fillStyle = gameState.nightShift ? '#1a1a2e' : '#2d3748';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = gameState.nightShift ? '#2a2a4a' : '#3a4659';
            ctx.lineWidth = 2; ctx.beginPath();
            for (let x = 0; x < canvas.width; x += 40) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = 0; y < canvas.height; y += 40) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            entities.sort((a, b) => a.pos.y - b.pos.y);
            entities.forEach(e => e.draw(ctx));

            ctx.font = 'bold 20px Arial';
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillText(p.text, p.x, p.y); });

            drawNightShiftOverlay();
            drawTutorialOverlay();

            if (gameState.paused) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f687b3';
                ctx.font = 'bold 60px "Vt323"';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.pausePhrase, canvas.width / 2, canvas.height / 2);
                ctx.restore();
            }
        }

        function drawMugScreen() {
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const mugX = canvas.width / 2;
            const mugY = canvas.height / 2;
            const mugW = 240; // Wider top
            const mugBaseW = 180; // Narrower bottom
            const mugH = 500; // Taller cup

            // Draw Shadow/Outline Cup
            ctx.save();
            ctx.translate(mugX, mugY);

            // Cup Shape Path
            ctx.beginPath();
            ctx.moveTo(-mugW / 2, -mugH / 2);
            ctx.lineTo(mugW / 2, -mugH / 2);
            ctx.lineTo(mugBaseW / 2, mugH / 2);
            ctx.lineTo(-mugBaseW / 2, mugH / 2);
            ctx.closePath();

            // Fill with shadow color
            ctx.fillStyle = '#2d3748';
            ctx.fill();

            // Outline
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Straw (optional detail)
            ctx.fillStyle = '#4299e1';
            ctx.fillRect(20, -mugH / 2 - 80, 20, 100);

            ctx.restore();

            // Draw Stickers
            gameState.mugStickers.forEach(s => {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);

                // Sticker Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.roundRect(-s.width / 2 + 4, -s.h / 2 + 4, s.width, s.h, 5);
                ctx.fill();

                // Sticker Body
                ctx.fillStyle = s.color;
                ctx.beginPath();
                ctx.roundRect(-s.width / 2, -s.h / 2, s.width, s.h, 5);
                ctx.fill();

                // Sticker Outline
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Text
                ctx.fillStyle = 'black';
                ctx.font = '20px "Vt323"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(s.text, 0, 0);

                ctx.restore();
            });

            // Draw Score
            ctx.fillStyle = 'white';
            ctx.font = '60px "Vt323"';
            ctx.textAlign = 'center';
            ctx.fillText(`SCORE: ${gameState.displayedScore}`, mugX, 100);

            if (gameState.inventoryStickers.length === 0 && gameState.stickerDelay <= 0) {
                ctx.fillStyle = '#48bb78';
                ctx.font = '40px "Vt323"';
                ctx.textAlign = 'center';
                ctx.fillText("SHIFT COMPLETE", mugX, canvas.height - 50);
            }
        }

        function drawSummaryScreen() {
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'white';
            ctx.font = '60px "Vt323"';
            ctx.textAlign = 'center';
            ctx.fillText("SHIFT SUMMARY", canvas.width / 2, 100);

            ctx.font = '30px "Vt323"';
            ctx.textAlign = 'left';
            const startX = canvas.width / 2 - 150;
            let y = 200;

            ctx.fillText(`Babies Fed: ${gameState.stats.babiesFed}`, startX, y); y += 50;
            ctx.fillText(`Diapers Changed: ${gameState.stats.diapersChanged}`, startX, y); y += 50;
            ctx.fillText(`Families Calmed: ${gameState.stats.familiesCalmed}`, startX, y); y += 50;
            ctx.fillText(`Alarms Silenced: ${gameState.stats.alarmsSilenced}`, startX, y); y += 50;
            ctx.fillText(`Coffee Consumed: ${gameState.stats.coffeeConsumed}`, startX, y); y += 50;

            ctx.textAlign = 'center';
            ctx.fillText(`Total Score: ${gameState.score}`, canvas.width / 2, y + 50);

            // Draw "Next" Button
            ctx.fillStyle = '#4299e1';
            ctx.fillRect(canvas.width / 2 - 100, canvas.height - 150, 200, 60);
            ctx.fillStyle = 'white';
            ctx.font = '40px "Vt323"';
            ctx.fillText("NEXT >", canvas.width / 2, canvas.height - 110);
        }

        function drawSticker(s) {
            ctx.save();
            ctx.translate(s.x, s.y);

            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.roundRect(-s.width / 2, -s.h / 2, s.width, s.h, 5);
            ctx.fill();

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = 'black';
            ctx.font = '24px "Vt323"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(s.text, 0, 0);

            ctx.restore();
        }

        function drawTutorialOverlay() {
            if (gameState.tutorialMessage.alpha <= 0) return;

            ctx.save();
            ctx.globalAlpha = gameState.tutorialMessage.alpha;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.roundRect(canvas.width / 2 - 300, 100, 600, 60, 10);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = '30px "Vt323"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(gameState.tutorialMessage.text, canvas.width / 2, 130);
            ctx.restore();
        }

        function showTutorial(text) {
            gameState.tutorialMessage.text = text;
            gameState.tutorialMessage.timer = 5000; // Show for 5 seconds
            gameState.tutorialMessage.alpha = 1;
        }

        function drawReportOff() {
            // Draw background (dimmed game)
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw floor lines
            ctx.strokeStyle = '#3a4659';
            ctx.lineWidth = 2; ctx.beginPath();
            for (let x = 0; x < canvas.width; x += 40) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = 0; y < canvas.height; y += 40) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            // Draw Player Nurse (Idle)
            drawSprite(ctx, 'nurse', nurse.pos.x, nurse.pos.y);

            // Draw Incoming Nurse
            drawSprite(ctx, 'nurse', gameState.incomingNursePos.x, gameState.incomingNursePos.y);

            // Dialogue
            ctx.font = '24px "Vt323"';
            ctx.textAlign = 'center';

            if (gameState.cutsceneTimer > 2000 && gameState.cutsceneTimer < 4000) {
                // Incoming Nurse speaks
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(gameState.incomingNursePos.x - 60, gameState.incomingNursePos.y - 100, 120, 60, 5);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.fillText("I'm here!", gameState.incomingNursePos.x, gameState.incomingNursePos.y - 60);
            } else if (gameState.cutsceneTimer > 4000 && gameState.cutsceneTimer < 6000) {
                // Player Nurse speaks
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(nurse.pos.x - 60, nurse.pos.y - 100, 120, 60, 5);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.fillText("All yours.", nurse.pos.x, nurse.pos.y - 60);
            }
        }

        function updateHUD() {
            const hours = Math.floor(gameState.time / 60);
            const mins = Math.min(59, Math.floor(gameState.time % 60)); // FIXED: Prevent 60 minutes
            timerDisplay.innerText = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            scoreDisplay.innerText = gameState.score;
            sanityBar.style.width = `${Math.max(0, gameState.sanity)}%`;
            if (gameState.sanity > 50) sanityBar.style.backgroundColor = '#48bb78';
            else if (gameState.sanity > 20) sanityBar.style.backgroundColor = '#ecc94b';
            else sanityBar.style.backgroundColor = '#f56565';
        }

        function playSoundVisual(x, y, text) {
            particles.push({ x: x, y: y - 20, text: text, color: '#fff', life: 60 });
        }

        function loop(timestamp) {
            if (!gameState.paused) {
                const dt = timestamp - gameState.lastTime;
                gameState.lastTime = timestamp;
                update(dt);
            }
            draw();
            if (gameState.running) requestAnimationFrame(loop);
        }

        function startGame() {
            modalOverlay.style.display = 'none';
            initGame();
            gameState.running = true;
            gameState.lastTime = performance.now();
            requestAnimationFrame(loop);
            showMessage("Shift Start!");
        }

        function endGame(victory) {
            if (!victory) {
                // Game Over (Sanity 0) - Skip report off, go straight to summary (or maybe game over screen?)
                // For now, let's just go to summary but maybe with a different message?
                // Actually, let's keep it simple and just do report off for victory (shift complete)
                // But if sanity is 0, maybe we should just show summary with "Shift Failed"?
                // The original code went to MUG.
                // Let's do Report Off only if victory (Time ran out).
                // If sanity 0, maybe skip to summary.
            }

            gameState.mode = 'REPORTOFF';
            gameState.cutsceneTimer = 0;
            gameState.incomingNursePos = { x: canvas.width + 50, y: canvas.height / 2 };

            gameUiTop.style.display = 'none';
            logPanel.style.display = 'none';
            messageBox.style.opacity = 0;
            restartBtn.style.display = 'none';

            // Set tutorial as seen after first game ends
            settings.tutorialSeen = true;

            // Prepare stickers for Mug screen (logic remains same)
            const stickerPhrases = [
                // Original phrases
                "Tiny Dictator", "NPO means NO", "Coffee IV", "Chart This",
                "Screaming Potato", "Vein Whisperer", "Chaos Coordinator",
                "Nap Time?", "Code Brown", "Shhh!", "Tired.", "Nope.",
                // Sprint 5: New phrases
                "Hand Hygiene Queen", "Alarm Silencer", "NPO Enforcer",
                "No Flash Photos", "I Need Backup", "Intake/Output",
                "15 Minute Chart", "Family Education", "Code Brown Survivor",
                "Tandem Nursing", "Skin-to-Skin", "Beep Beep Beep",
                "Where's RT?", "Call the Fellow", "Not My Patient",
                "I Forgot to Chart", "Pizza Party?", "Mandatory Training",
                "Float Pool", "Short Staffed"
            ];
            const colors = ['#feb2b2', '#fbd38d', '#9ae6b4', '#81e6d9', '#90cdf4', '#d6bcfa'];

            const count = Math.max(1, Math.floor(gameState.score / 200));

            gameState.inventoryStickers = [];
            gameState.displayedScore = 0; // Reset displayed score
            gameState.mugFillHeight = 0; // Reset fill height

            for (let i = 0; i < count; i++) {
                const txt = stickerPhrases[Math.floor(Math.random() * stickerPhrases.length)];
                const col = colors[Math.floor(Math.random() * colors.length)];
                const s = new Sticker(txt, col);
                // No x/y needed for inventory anymore
                gameState.inventoryStickers.push(s);
            }
            gameState.mugStickers = [];
            gameState.stickerDelay = 60; // Initial delay
        }

        // Global error handler
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            const errorMsg = `Error: ${msg} at line ${lineNo}`;
            console.error(errorMsg);
            // Try to log to game panel if possible
            try {
                if (logPanel) {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.style.color = 'red';
                    entry.innerText = errorMsg;
                    logPanel.prepend(entry);
                }
            } catch (e) { }
            return false;
        };

        function showMessage(text) {
            messageText.innerText = text;
            messageBox.style.display = 'block';
            // Force reflow
            void messageBox.offsetWidth;
            messageBox.style.opacity = 1;

            setTimeout(() => {
                messageBox.style.opacity = 0;
                setTimeout(() => {
                    if (messageBox.style.opacity === '0') {
                        messageBox.style.display = 'none';
                    }
                }, 500); // Wait for transition
            }, 3000);
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function handlePointerDown(e) {
            // Allow clicks on canvas OR the container (in case of letterboxing)
            const isCanvas = e.target === canvas;
            const isContainer = e.target.id === 'game-container';

            if (!isCanvas && !isContainer) return;

            const pos = getMousePos(e);

            if (gameState.mode === 'MUG') {
                return;
            }

            if (gameState.mode === 'SUMMARY') {
                // Check click on Next button
                if (pos.x > canvas.width / 2 - 100 && pos.x < canvas.width / 2 + 100 &&
                    pos.y > canvas.height - 150 && pos.y < canvas.height - 90) {
                    gameState.mode = 'MUG';
                    playBeep(600, 100);
                }
                return;
            }

            if (gameState.mode === 'REPORTOFF') return;

            if (!gameState.running || gameState.paused) return;

            particles.push({ x: pos.x, y: pos.y, text: '.', color: '#fff', life: 10 });

            if (nurse.state === 'sitting') {
                nurse.state = 'moving'; nurse.target = new Vector(pos.x, pos.y);
                nurse.say("Back to work...", 'nurse');
                return;
            }

            const items = entities.filter(ent => ['coffee', 'pizza', 'bathroom', 'admingift'].includes(ent.type));
            for (let item of items) {
                // FIXED: Check if CLICK is on item, not if nurse is close
                if (item.pos.dist(pos) < 40 + item.size / 2) {
                    nurse.target = new Vector(item.pos.x, item.pos.y); nurse.state = 'moving'; return;
                }
            }
            const enemies = entities.filter(ent => ['resident', 'mom', 'dad', 'surgeon'].includes(ent.type) && ent.active);
            for (let enemy of enemies) {
                // FIXED: Check if CLICK is on enemy
                if (enemy.pos.dist(pos) < 40 + enemy.size / 2) {
                    nurse.target = new Vector(enemy.pos.x, enemy.pos.y); nurse.state = 'moving'; return;
                }
            }
            for (let iso of isolettes) {
                // FIXED: Check if CLICK is on isolette
                if (iso.pos.dist(pos) < 40 + iso.size / 2) {
                    nurse.target = new Vector(iso.pos.x, iso.pos.y + 30); nurse.state = 'moving'; return;
                }
            }
            // Chair check was already using pos.dist, but let's be consistent
            if (chair.pos.dist(pos) < 40 + chair.size) {
                nurse.target = new Vector(chair.pos.x, chair.pos.y);
                nurse.state = 'moving';
                return;
            }

            nurse.target = new Vector(pos.x, pos.y);
            nurse.state = 'moving';
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('mousedown', handlePointerDown);
        window.addEventListener('touchstart', (e) => {
            if (e.target === canvas || e.target.id === 'game-container') {
                e.preventDefault(); // Prevent mouse emulation only on canvas/container
                handlePointerDown(e.touches[0]);
            }
        }, { passive: false });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = true;
            if (key === 'a' || key === 'arrowleft') keys.a = true;
            if (key === 's' || key === 'arrowdown') keys.s = true;
            if (key === 'd' || key === 'arrowright') keys.d = true;
            if (key === 'arrowup') keys.up = true;
            if (key === 'arrowdown') keys.down = true;
            if (key === 'arrowleft') keys.left = true;
            if (key === 'arrowright') keys.right = true;
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = false;
            if (key === 'a' || key === 'arrowleft') keys.a = false;
            if (key === 's' || key === 'arrowdown') keys.s = false;
            if (key === 'd' || key === 'arrowright') keys.d = false;
            if (key === 'arrowup') keys.up = false;
            if (key === 'arrowdown') keys.down = false;
            if (key === 'arrowleft') keys.left = false;
            if (key === 'arrowright') keys.right = false;
        });

        resizeCanvas();
    </script>
</body>

</html>